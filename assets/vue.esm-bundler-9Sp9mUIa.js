function makeMap(str,expectsLowerCase){const map=Object.create(null),list=str.split(",");for(let i=0;i<list.length;i++)map[list[i]]=!0;return expectsLowerCase?val=>!!map[val.toLowerCase()]:val=>!!map[val]}const EMPTY_OBJ={},EMPTY_ARR=[],NOOP=()=>{},NO=()=>!1,onRE=/^on[^a-z]/,isOn=key=>onRE.test(key),isModelListener=key=>key.startsWith("onUpdate:"),extend=Object.assign,remove=(arr,el)=>{const i=arr.indexOf(el);i>-1&&arr.splice(i,1)},hasOwnProperty$1=Object.prototype.hasOwnProperty,hasOwn=(val,key)=>hasOwnProperty$1.call(val,key),isArray=Array.isArray,isMap=val=>toTypeString(val)==="[object Map]",isSet=val=>toTypeString(val)==="[object Set]",isDate=val=>toTypeString(val)==="[object Date]",isRegExp=val=>toTypeString(val)==="[object RegExp]",isFunction=val=>typeof val=="function",isString=val=>typeof val=="string",isSymbol=val=>typeof val=="symbol",isObject=val=>val!==null&&typeof val=="object",isPromise=val=>(isObject(val)||isFunction(val))&&isFunction(val.then)&&isFunction(val.catch),objectToString=Object.prototype.toString,toTypeString=value=>objectToString.call(value),toRawType=value=>toTypeString(value).slice(8,-1),isPlainObject=val=>toTypeString(val)==="[object Object]",isIntegerKey=key=>isString(key)&&key!=="NaN"&&key[0]!=="-"&&""+parseInt(key,10)===key,isReservedProp=makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),isBuiltInDirective=makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),cacheStringFunction=fn=>{const cache=Object.create(null);return str=>cache[str]||(cache[str]=fn(str))},camelizeRE=/-(\w)/g,camelize=cacheStringFunction(str=>str.replace(camelizeRE,(_,c)=>c?c.toUpperCase():"")),hyphenateRE=/\B([A-Z])/g,hyphenate=cacheStringFunction(str=>str.replace(hyphenateRE,"-$1").toLowerCase()),capitalize=cacheStringFunction(str=>str.charAt(0).toUpperCase()+str.slice(1)),toHandlerKey=cacheStringFunction(str=>str?`on${capitalize(str)}`:""),hasChanged=(value,oldValue)=>!Object.is(value,oldValue),invokeArrayFns=(fns,arg)=>{for(let i=0;i<fns.length;i++)fns[i](arg)},def=(obj,key,value)=>{Object.defineProperty(obj,key,{configurable:!0,enumerable:!1,value})},looseToNumber=val=>{const n=parseFloat(val);return isNaN(n)?val:n},toNumber=val=>{const n=isString(val)?Number(val):NaN;return isNaN(n)?val:n};let _globalThis;const getGlobalThis=()=>_globalThis||(_globalThis=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),GLOBALS_ALLOWED="Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console",isGloballyAllowed=makeMap(GLOBALS_ALLOWED);function normalizeStyle(value){if(isArray(value)){const res={};for(let i=0;i<value.length;i++){const item=value[i],normalized=isString(item)?parseStringStyle(item):normalizeStyle(item);if(normalized)for(const key in normalized)res[key]=normalized[key]}return res}else if(isString(value)||isObject(value))return value}const listDelimiterRE=/;(?![^(]*\))/g,propertyDelimiterRE=/:([^]+)/,styleCommentRE=/\/\*[^]*?\*\//g;function parseStringStyle(cssText){const ret={};return cssText.replace(styleCommentRE,"").split(listDelimiterRE).forEach(item=>{if(item){const tmp=item.split(propertyDelimiterRE);tmp.length>1&&(ret[tmp[0].trim()]=tmp[1].trim())}}),ret}function normalizeClass(value){let res="";if(isString(value))res=value;else if(isArray(value))for(let i=0;i<value.length;i++){const normalized=normalizeClass(value[i]);normalized&&(res+=normalized+" ")}else if(isObject(value))for(const name in value)value[name]&&(res+=name+" ");return res.trim()}function normalizeProps(props){if(!props)return null;let{class:klass,style}=props;return klass&&!isString(klass)&&(props.class=normalizeClass(klass)),style&&(props.style=normalizeStyle(style)),props}const HTML_TAGS="html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",SVG_TAGS="svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",VOID_TAGS="area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr",isHTMLTag=makeMap(HTML_TAGS),isSVGTag=makeMap(SVG_TAGS),isVoidTag=makeMap(VOID_TAGS),specialBooleanAttrs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",isSpecialBooleanAttr=makeMap(specialBooleanAttrs);function includeBooleanAttr(value){return!!value||value===""}function looseCompareArrays(a,b){if(a.length!==b.length)return!1;let equal=!0;for(let i=0;equal&&i<a.length;i++)equal=looseEqual(a[i],b[i]);return equal}function looseEqual(a,b){if(a===b)return!0;let aValidType=isDate(a),bValidType=isDate(b);if(aValidType||bValidType)return aValidType&&bValidType?a.getTime()===b.getTime():!1;if(aValidType=isSymbol(a),bValidType=isSymbol(b),aValidType||bValidType)return a===b;if(aValidType=isArray(a),bValidType=isArray(b),aValidType||bValidType)return aValidType&&bValidType?looseCompareArrays(a,b):!1;if(aValidType=isObject(a),bValidType=isObject(b),aValidType||bValidType){if(!aValidType||!bValidType)return!1;const aKeysCount=Object.keys(a).length,bKeysCount=Object.keys(b).length;if(aKeysCount!==bKeysCount)return!1;for(const key in a){const aHasKey=a.hasOwnProperty(key),bHasKey=b.hasOwnProperty(key);if(aHasKey&&!bHasKey||!aHasKey&&bHasKey||!looseEqual(a[key],b[key]))return!1}}return String(a)===String(b)}function looseIndexOf(arr,val){return arr.findIndex(item=>looseEqual(item,val))}const toDisplayString=val=>isString(val)?val:val==null?"":isArray(val)||isObject(val)&&(val.toString===objectToString||!isFunction(val.toString))?JSON.stringify(val,replacer,2):String(val),replacer=(_key,val)=>val&&val.__v_isRef?replacer(_key,val.value):isMap(val)?{[`Map(${val.size})`]:[...val.entries()].reduce((entries,[key,val2])=>(entries[`${key} =>`]=val2,entries),{})}:isSet(val)?{[`Set(${val.size})`]:[...val.values()]}:isObject(val)&&!isArray(val)&&!isPlainObject(val)?String(val):val;let activeEffectScope;class EffectScope{constructor(detached=!1){this.detached=detached,this._active=!0,this.effects=[],this.cleanups=[],this.parent=activeEffectScope,!detached&&activeEffectScope&&(this.index=(activeEffectScope.scopes||(activeEffectScope.scopes=[])).push(this)-1)}get active(){return this._active}run(fn){if(this._active){const currentEffectScope=activeEffectScope;try{return activeEffectScope=this,fn()}finally{activeEffectScope=currentEffectScope}}}on(){activeEffectScope=this}off(){activeEffectScope=this.parent}stop(fromParent){if(this._active){let i,l;for(i=0,l=this.effects.length;i<l;i++)this.effects[i].stop();for(i=0,l=this.cleanups.length;i<l;i++)this.cleanups[i]();if(this.scopes)for(i=0,l=this.scopes.length;i<l;i++)this.scopes[i].stop(!0);if(!this.detached&&this.parent&&!fromParent){const last2=this.parent.scopes.pop();last2&&last2!==this&&(this.parent.scopes[this.index]=last2,last2.index=this.index)}this.parent=void 0,this._active=!1}}}function effectScope(detached){return new EffectScope(detached)}function recordEffectScope(effect2,scope=activeEffectScope){scope&&scope.active&&scope.effects.push(effect2)}function getCurrentScope(){return activeEffectScope}function onScopeDispose(fn){activeEffectScope&&activeEffectScope.cleanups.push(fn)}const createDep=effects=>{const dep=new Set(effects);return dep.w=0,dep.n=0,dep},wasTracked=dep=>(dep.w&trackOpBit)>0,newTracked=dep=>(dep.n&trackOpBit)>0,initDepMarkers=({deps})=>{if(deps.length)for(let i=0;i<deps.length;i++)deps[i].w|=trackOpBit},finalizeDepMarkers=effect2=>{const{deps}=effect2;if(deps.length){let ptr=0;for(let i=0;i<deps.length;i++){const dep=deps[i];wasTracked(dep)&&!newTracked(dep)?dep.delete(effect2):deps[ptr++]=dep,dep.w&=~trackOpBit,dep.n&=~trackOpBit}deps.length=ptr}},targetMap=new WeakMap;let effectTrackDepth=0,trackOpBit=1;const maxMarkerBits=30;let activeEffect;const ITERATE_KEY=Symbol(""),MAP_KEY_ITERATE_KEY=Symbol("");class ReactiveEffect{constructor(fn,scheduler2=null,scope){this.fn=fn,this.scheduler=scheduler2,this.active=!0,this.deps=[],this.parent=void 0,recordEffectScope(this,scope)}run(){if(!this.active)return this.fn();let parent=activeEffect,lastShouldTrack=shouldTrack;for(;parent;){if(parent===this)return;parent=parent.parent}try{return this.parent=activeEffect,activeEffect=this,shouldTrack=!0,trackOpBit=1<<++effectTrackDepth,effectTrackDepth<=maxMarkerBits?initDepMarkers(this):cleanupEffect(this),this.fn()}finally{effectTrackDepth<=maxMarkerBits&&finalizeDepMarkers(this),trackOpBit=1<<--effectTrackDepth,activeEffect=this.parent,shouldTrack=lastShouldTrack,this.parent=void 0,this.deferStop&&this.stop()}}stop(){activeEffect===this?this.deferStop=!0:this.active&&(cleanupEffect(this),this.onStop&&this.onStop(),this.active=!1)}}function cleanupEffect(effect2){const{deps}=effect2;if(deps.length){for(let i=0;i<deps.length;i++)deps[i].delete(effect2);deps.length=0}}function effect(fn,options){fn.effect instanceof ReactiveEffect&&(fn=fn.effect.fn);const _effect=new ReactiveEffect(fn);options&&(extend(_effect,options),options.scope&&recordEffectScope(_effect,options.scope)),(!options||!options.lazy)&&_effect.run();const runner=_effect.run.bind(_effect);return runner.effect=_effect,runner}function stop(runner){runner.effect.stop()}let shouldTrack=!0;const trackStack=[];function pauseTracking(){trackStack.push(shouldTrack),shouldTrack=!1}function resetTracking(){const last2=trackStack.pop();shouldTrack=last2===void 0?!0:last2}function track(target,type,key){if(shouldTrack&&activeEffect){let depsMap=targetMap.get(target);depsMap||targetMap.set(target,depsMap=new Map);let dep=depsMap.get(key);dep||depsMap.set(key,dep=createDep()),trackEffects(dep)}}function trackEffects(dep,debuggerEventExtraInfo){let shouldTrack2=!1;effectTrackDepth<=maxMarkerBits?newTracked(dep)||(dep.n|=trackOpBit,shouldTrack2=!wasTracked(dep)):shouldTrack2=!dep.has(activeEffect),shouldTrack2&&(dep.add(activeEffect),activeEffect.deps.push(dep))}function trigger(target,type,key,newValue,oldValue,oldTarget){const depsMap=targetMap.get(target);if(!depsMap)return;let deps=[];if(type==="clear")deps=[...depsMap.values()];else if(key==="length"&&isArray(target)){const newLength=Number(newValue);depsMap.forEach((dep,key2)=>{(key2==="length"||!isSymbol(key2)&&key2>=newLength)&&deps.push(dep)})}else switch(key!==void 0&&deps.push(depsMap.get(key)),type){case"add":isArray(target)?isIntegerKey(key)&&deps.push(depsMap.get("length")):(deps.push(depsMap.get(ITERATE_KEY)),isMap(target)&&deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"delete":isArray(target)||(deps.push(depsMap.get(ITERATE_KEY)),isMap(target)&&deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)));break;case"set":isMap(target)&&deps.push(depsMap.get(ITERATE_KEY));break}if(deps.length===1)deps[0]&&triggerEffects(deps[0]);else{const effects=[];for(const dep of deps)dep&&effects.push(...dep);triggerEffects(createDep(effects))}}function triggerEffects(dep,debuggerEventExtraInfo){const effects=isArray(dep)?dep:[...dep];for(const effect2 of effects)effect2.computed&&triggerEffect(effect2);for(const effect2 of effects)effect2.computed||triggerEffect(effect2)}function triggerEffect(effect2,debuggerEventExtraInfo){(effect2!==activeEffect||effect2.allowRecurse)&&(effect2.scheduler?effect2.scheduler():effect2.run())}function getDepFromReactive(object,key){var _a;return(_a=targetMap.get(object))==null?void 0:_a.get(key)}const isNonTrackableKeys=makeMap("__proto__,__v_isRef,__isVue"),builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).filter(key=>key!=="arguments"&&key!=="caller").map(key=>Symbol[key]).filter(isSymbol)),arrayInstrumentations=createArrayInstrumentations();function createArrayInstrumentations(){const instrumentations={};return["includes","indexOf","lastIndexOf"].forEach(key=>{instrumentations[key]=function(...args){const arr=toRaw(this);for(let i=0,l=this.length;i<l;i++)track(arr,"get",i+"");const res=arr[key](...args);return res===-1||res===!1?arr[key](...args.map(toRaw)):res}}),["push","pop","shift","unshift","splice"].forEach(key=>{instrumentations[key]=function(...args){pauseTracking();const res=toRaw(this)[key].apply(this,args);return resetTracking(),res}}),instrumentations}function hasOwnProperty(key){const obj=toRaw(this);return track(obj,"has",key),obj.hasOwnProperty(key)}class BaseReactiveHandler{constructor(_isReadonly=!1,_shallow=!1){this._isReadonly=_isReadonly,this._shallow=_shallow}get(target,key,receiver){const isReadonly2=this._isReadonly,shallow=this._shallow;if(key==="__v_isReactive")return!isReadonly2;if(key==="__v_isReadonly")return isReadonly2;if(key==="__v_isShallow")return shallow;if(key==="__v_raw"&&receiver===(isReadonly2?shallow?shallowReadonlyMap:readonlyMap:shallow?shallowReactiveMap:reactiveMap).get(target))return target;const targetIsArray=isArray(target);if(!isReadonly2){if(targetIsArray&&hasOwn(arrayInstrumentations,key))return Reflect.get(arrayInstrumentations,key,receiver);if(key==="hasOwnProperty")return hasOwnProperty}const res=Reflect.get(target,key,receiver);return(isSymbol(key)?builtInSymbols.has(key):isNonTrackableKeys(key))||(isReadonly2||track(target,"get",key),shallow)?res:isRef(res)?targetIsArray&&isIntegerKey(key)?res:res.value:isObject(res)?isReadonly2?readonly(res):reactive(res):res}}class MutableReactiveHandler extends BaseReactiveHandler{constructor(shallow=!1){super(!1,shallow)}set(target,key,value,receiver){let oldValue=target[key];if(isReadonly(oldValue)&&isRef(oldValue)&&!isRef(value))return!1;if(!this._shallow&&(!isShallow(value)&&!isReadonly(value)&&(oldValue=toRaw(oldValue),value=toRaw(value)),!isArray(target)&&isRef(oldValue)&&!isRef(value)))return oldValue.value=value,!0;const hadKey=isArray(target)&&isIntegerKey(key)?Number(key)<target.length:hasOwn(target,key),result=Reflect.set(target,key,value,receiver);return target===toRaw(receiver)&&(hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value):trigger(target,"add",key,value)),result}deleteProperty(target,key){const hadKey=hasOwn(target,key);target[key];const result=Reflect.deleteProperty(target,key);return result&&hadKey&&trigger(target,"delete",key,void 0),result}has(target,key){const result=Reflect.has(target,key);return(!isSymbol(key)||!builtInSymbols.has(key))&&track(target,"has",key),result}ownKeys(target){return track(target,"iterate",isArray(target)?"length":ITERATE_KEY),Reflect.ownKeys(target)}}class ReadonlyReactiveHandler extends BaseReactiveHandler{constructor(shallow=!1){super(!0,shallow)}set(target,key){return!0}deleteProperty(target,key){return!0}}const mutableHandlers=new MutableReactiveHandler,readonlyHandlers=new ReadonlyReactiveHandler,shallowReactiveHandlers=new MutableReactiveHandler(!0),shallowReadonlyHandlers=new ReadonlyReactiveHandler(!0),toShallow=value=>value,getProto=v=>Reflect.getPrototypeOf(v);function get(target,key,isReadonly2=!1,isShallow2=!1){target=target.__v_raw;const rawTarget=toRaw(target),rawKey=toRaw(key);isReadonly2||(hasChanged(key,rawKey)&&track(rawTarget,"get",key),track(rawTarget,"get",rawKey));const{has:has2}=getProto(rawTarget),wrap=isShallow2?toShallow:isReadonly2?toReadonly:toReactive;if(has2.call(rawTarget,key))return wrap(target.get(key));if(has2.call(rawTarget,rawKey))return wrap(target.get(rawKey));target!==rawTarget&&target.get(key)}function has(key,isReadonly2=!1){const target=this.__v_raw,rawTarget=toRaw(target),rawKey=toRaw(key);return isReadonly2||(hasChanged(key,rawKey)&&track(rawTarget,"has",key),track(rawTarget,"has",rawKey)),key===rawKey?target.has(key):target.has(key)||target.has(rawKey)}function size(target,isReadonly2=!1){return target=target.__v_raw,!isReadonly2&&track(toRaw(target),"iterate",ITERATE_KEY),Reflect.get(target,"size",target)}function add(value){value=toRaw(value);const target=toRaw(this);return getProto(target).has.call(target,value)||(target.add(value),trigger(target,"add",value,value)),this}function set(key,value){value=toRaw(value);const target=toRaw(this),{has:has2,get:get2}=getProto(target);let hadKey=has2.call(target,key);hadKey||(key=toRaw(key),hadKey=has2.call(target,key));const oldValue=get2.call(target,key);return target.set(key,value),hadKey?hasChanged(value,oldValue)&&trigger(target,"set",key,value):trigger(target,"add",key,value),this}function deleteEntry(key){const target=toRaw(this),{has:has2,get:get2}=getProto(target);let hadKey=has2.call(target,key);hadKey||(key=toRaw(key),hadKey=has2.call(target,key)),get2&&get2.call(target,key);const result=target.delete(key);return hadKey&&trigger(target,"delete",key,void 0),result}function clear(){const target=toRaw(this),hadItems=target.size!==0,result=target.clear();return hadItems&&trigger(target,"clear",void 0,void 0),result}function createForEach(isReadonly2,isShallow2){return function(callback,thisArg){const observed=this,target=observed.__v_raw,rawTarget=toRaw(target),wrap=isShallow2?toShallow:isReadonly2?toReadonly:toReactive;return!isReadonly2&&track(rawTarget,"iterate",ITERATE_KEY),target.forEach((value,key)=>callback.call(thisArg,wrap(value),wrap(key),observed))}}function createIterableMethod(method,isReadonly2,isShallow2){return function(...args){const target=this.__v_raw,rawTarget=toRaw(target),targetIsMap=isMap(rawTarget),isPair=method==="entries"||method===Symbol.iterator&&targetIsMap,isKeyOnly=method==="keys"&&targetIsMap,innerIterator=target[method](...args),wrap=isShallow2?toShallow:isReadonly2?toReadonly:toReactive;return!isReadonly2&&track(rawTarget,"iterate",isKeyOnly?MAP_KEY_ITERATE_KEY:ITERATE_KEY),{next(){const{value,done}=innerIterator.next();return done?{value,done}:{value:isPair?[wrap(value[0]),wrap(value[1])]:wrap(value),done}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(type){return function(...args){return type==="delete"?!1:type==="clear"?void 0:this}}function createInstrumentations(){const mutableInstrumentations2={get(key){return get(this,key)},get size(){return size(this)},has,add,set,delete:deleteEntry,clear,forEach:createForEach(!1,!1)},shallowInstrumentations2={get(key){return get(this,key,!1,!0)},get size(){return size(this)},has,add,set,delete:deleteEntry,clear,forEach:createForEach(!1,!0)},readonlyInstrumentations2={get(key){return get(this,key,!0)},get size(){return size(this,!0)},has(key){return has.call(this,key,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!1)},shallowReadonlyInstrumentations2={get(key){return get(this,key,!0,!0)},get size(){return size(this,!0)},has(key){return has.call(this,key,!0)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(method=>{mutableInstrumentations2[method]=createIterableMethod(method,!1,!1),readonlyInstrumentations2[method]=createIterableMethod(method,!0,!1),shallowInstrumentations2[method]=createIterableMethod(method,!1,!0),shallowReadonlyInstrumentations2[method]=createIterableMethod(method,!0,!0)}),[mutableInstrumentations2,readonlyInstrumentations2,shallowInstrumentations2,shallowReadonlyInstrumentations2]}const[mutableInstrumentations,readonlyInstrumentations,shallowInstrumentations,shallowReadonlyInstrumentations]=createInstrumentations();function createInstrumentationGetter(isReadonly2,shallow){const instrumentations=shallow?isReadonly2?shallowReadonlyInstrumentations:shallowInstrumentations:isReadonly2?readonlyInstrumentations:mutableInstrumentations;return(target,key,receiver)=>key==="__v_isReactive"?!isReadonly2:key==="__v_isReadonly"?isReadonly2:key==="__v_raw"?target:Reflect.get(hasOwn(instrumentations,key)&&key in target?instrumentations:target,key,receiver)}const mutableCollectionHandlers={get:createInstrumentationGetter(!1,!1)},shallowCollectionHandlers={get:createInstrumentationGetter(!1,!0)},readonlyCollectionHandlers={get:createInstrumentationGetter(!0,!1)},shallowReadonlyCollectionHandlers={get:createInstrumentationGetter(!0,!0)},reactiveMap=new WeakMap,shallowReactiveMap=new WeakMap,readonlyMap=new WeakMap,shallowReadonlyMap=new WeakMap;function targetTypeMap(rawType){switch(rawType){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function getTargetType(value){return value.__v_skip||!Object.isExtensible(value)?0:targetTypeMap(toRawType(value))}function reactive(target){return isReadonly(target)?target:createReactiveObject(target,!1,mutableHandlers,mutableCollectionHandlers,reactiveMap)}function shallowReactive(target){return createReactiveObject(target,!1,shallowReactiveHandlers,shallowCollectionHandlers,shallowReactiveMap)}function readonly(target){return createReactiveObject(target,!0,readonlyHandlers,readonlyCollectionHandlers,readonlyMap)}function shallowReadonly(target){return createReactiveObject(target,!0,shallowReadonlyHandlers,shallowReadonlyCollectionHandlers,shallowReadonlyMap)}function createReactiveObject(target,isReadonly2,baseHandlers,collectionHandlers,proxyMap){if(!isObject(target)||target.__v_raw&&!(isReadonly2&&target.__v_isReactive))return target;const existingProxy=proxyMap.get(target);if(existingProxy)return existingProxy;const targetType=getTargetType(target);if(targetType===0)return target;const proxy=new Proxy(target,targetType===2?collectionHandlers:baseHandlers);return proxyMap.set(target,proxy),proxy}function isReactive(value){return isReadonly(value)?isReactive(value.__v_raw):!!(value&&value.__v_isReactive)}function isReadonly(value){return!!(value&&value.__v_isReadonly)}function isShallow(value){return!!(value&&value.__v_isShallow)}function isProxy(value){return isReactive(value)||isReadonly(value)}function toRaw(observed){const raw=observed&&observed.__v_raw;return raw?toRaw(raw):observed}function markRaw(value){return def(value,"__v_skip",!0),value}const toReactive=value=>isObject(value)?reactive(value):value,toReadonly=value=>isObject(value)?readonly(value):value;function trackRefValue(ref2){shouldTrack&&activeEffect&&(ref2=toRaw(ref2),trackEffects(ref2.dep||(ref2.dep=createDep())))}function triggerRefValue(ref2,newVal){ref2=toRaw(ref2);const dep=ref2.dep;dep&&triggerEffects(dep)}function isRef(r){return!!(r&&r.__v_isRef===!0)}function ref(value){return createRef(value,!1)}function shallowRef(value){return createRef(value,!0)}function createRef(rawValue,shallow){return isRef(rawValue)?rawValue:new RefImpl(rawValue,shallow)}class RefImpl{constructor(value,__v_isShallow){this.__v_isShallow=__v_isShallow,this.dep=void 0,this.__v_isRef=!0,this._rawValue=__v_isShallow?value:toRaw(value),this._value=__v_isShallow?value:toReactive(value)}get value(){return trackRefValue(this),this._value}set value(newVal){const useDirectValue=this.__v_isShallow||isShallow(newVal)||isReadonly(newVal);newVal=useDirectValue?newVal:toRaw(newVal),hasChanged(newVal,this._rawValue)&&(this._rawValue=newVal,this._value=useDirectValue?newVal:toReactive(newVal),triggerRefValue(this))}}function triggerRef(ref2){triggerRefValue(ref2)}function unref(ref2){return isRef(ref2)?ref2.value:ref2}function toValue(source){return isFunction(source)?source():unref(source)}const shallowUnwrapHandlers={get:(target,key,receiver)=>unref(Reflect.get(target,key,receiver)),set:(target,key,value,receiver)=>{const oldValue=target[key];return isRef(oldValue)&&!isRef(value)?(oldValue.value=value,!0):Reflect.set(target,key,value,receiver)}};function proxyRefs(objectWithRefs){return isReactive(objectWithRefs)?objectWithRefs:new Proxy(objectWithRefs,shallowUnwrapHandlers)}class CustomRefImpl{constructor(factory){this.dep=void 0,this.__v_isRef=!0;const{get:get2,set:set2}=factory(()=>trackRefValue(this),()=>triggerRefValue(this));this._get=get2,this._set=set2}get value(){return this._get()}set value(newVal){this._set(newVal)}}function customRef(factory){return new CustomRefImpl(factory)}function toRefs(object){const ret=isArray(object)?new Array(object.length):{};for(const key in object)ret[key]=propertyToRef(object,key);return ret}class ObjectRefImpl{constructor(_object,_key,_defaultValue){this._object=_object,this._key=_key,this._defaultValue=_defaultValue,this.__v_isRef=!0}get value(){const val=this._object[this._key];return val===void 0?this._defaultValue:val}set value(newVal){this._object[this._key]=newVal}get dep(){return getDepFromReactive(toRaw(this._object),this._key)}}class GetterRefImpl{constructor(_getter){this._getter=_getter,this.__v_isRef=!0,this.__v_isReadonly=!0}get value(){return this._getter()}}function toRef(source,key,defaultValue){return isRef(source)?source:isFunction(source)?new GetterRefImpl(source):isObject(source)&&arguments.length>1?propertyToRef(source,key,defaultValue):ref(source)}function propertyToRef(source,key,defaultValue){const val=source[key];return isRef(val)?val:new ObjectRefImpl(source,key,defaultValue)}class ComputedRefImpl{constructor(getter,_setter,isReadonly2,isSSR){this._setter=_setter,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new ReactiveEffect(getter,()=>{this._dirty||(this._dirty=!0,triggerRefValue(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!isSSR,this.__v_isReadonly=isReadonly2}get value(){const self2=toRaw(this);return trackRefValue(self2),(self2._dirty||!self2._cacheable)&&(self2._dirty=!1,self2._value=self2.effect.run()),self2._value}set value(newValue){this._setter(newValue)}}function computed$1(getterOrOptions,debugOptions,isSSR=!1){let getter,setter;const onlyGetter=isFunction(getterOrOptions);return onlyGetter?(getter=getterOrOptions,setter=NOOP):(getter=getterOrOptions.get,setter=getterOrOptions.set),new ComputedRefImpl(getter,setter,onlyGetter||!setter,isSSR)}function warn(msg,...args){}function assertNumber(val,type){}function callWithErrorHandling(fn,instance,type,args){let res;try{res=args?fn(...args):fn()}catch(err){handleError(err,instance,type)}return res}function callWithAsyncErrorHandling(fn,instance,type,args){if(isFunction(fn)){const res=callWithErrorHandling(fn,instance,type,args);return res&&isPromise(res)&&res.catch(err=>{handleError(err,instance,type)}),res}const values=[];for(let i=0;i<fn.length;i++)values.push(callWithAsyncErrorHandling(fn[i],instance,type,args));return values}function handleError(err,instance,type,throwInDev=!0){const contextVNode=instance?instance.vnode:null;if(instance){let cur=instance.parent;const exposedInstance=instance.proxy,errorInfo=type;for(;cur;){const errorCapturedHooks=cur.ec;if(errorCapturedHooks){for(let i=0;i<errorCapturedHooks.length;i++)if(errorCapturedHooks[i](err,exposedInstance,errorInfo)===!1)return}cur=cur.parent}const appErrorHandler=instance.appContext.config.errorHandler;if(appErrorHandler){callWithErrorHandling(appErrorHandler,null,10,[err,exposedInstance,errorInfo]);return}}logError(err,type,contextVNode,throwInDev)}function logError(err,type,contextVNode,throwInDev=!0){console.error(err)}let isFlushing=!1,isFlushPending=!1;const queue=[];let flushIndex=0;const pendingPostFlushCbs=[];let activePostFlushCbs=null,postFlushIndex=0;const resolvedPromise=Promise.resolve();let currentFlushPromise=null;function nextTick(fn){const p2=currentFlushPromise||resolvedPromise;return fn?p2.then(this?fn.bind(this):fn):p2}function findInsertionIndex(id){let start=flushIndex+1,end=queue.length;for(;start<end;){const middle=start+end>>>1,middleJob=queue[middle],middleJobId=getId(middleJob);middleJobId<id||middleJobId===id&&middleJob.pre?start=middle+1:end=middle}return start}function queueJob(job){(!queue.length||!queue.includes(job,isFlushing&&job.allowRecurse?flushIndex+1:flushIndex))&&(job.id==null?queue.push(job):queue.splice(findInsertionIndex(job.id),0,job),queueFlush())}function queueFlush(){!isFlushing&&!isFlushPending&&(isFlushPending=!0,currentFlushPromise=resolvedPromise.then(flushJobs))}function invalidateJob(job){const i=queue.indexOf(job);i>flushIndex&&queue.splice(i,1)}function queuePostFlushCb(cb){isArray(cb)?pendingPostFlushCbs.push(...cb):(!activePostFlushCbs||!activePostFlushCbs.includes(cb,cb.allowRecurse?postFlushIndex+1:postFlushIndex))&&pendingPostFlushCbs.push(cb),queueFlush()}function flushPreFlushCbs(seen2,i=isFlushing?flushIndex+1:0){for(;i<queue.length;i++){const cb=queue[i];cb&&cb.pre&&(queue.splice(i,1),i--,cb())}}function flushPostFlushCbs(seen2){if(pendingPostFlushCbs.length){const deduped=[...new Set(pendingPostFlushCbs)];if(pendingPostFlushCbs.length=0,activePostFlushCbs){activePostFlushCbs.push(...deduped);return}for(activePostFlushCbs=deduped,activePostFlushCbs.sort((a,b)=>getId(a)-getId(b)),postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++)activePostFlushCbs[postFlushIndex]();activePostFlushCbs=null,postFlushIndex=0}}const getId=job=>job.id==null?1/0:job.id,comparator=(a,b)=>{const diff=getId(a)-getId(b);if(diff===0){if(a.pre&&!b.pre)return-1;if(b.pre&&!a.pre)return 1}return diff};function flushJobs(seen2){isFlushPending=!1,isFlushing=!0,queue.sort(comparator);try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){const job=queue[flushIndex];job&&job.active!==!1&&callWithErrorHandling(job,null,14)}}finally{flushIndex=0,queue.length=0,flushPostFlushCbs(),isFlushing=!1,currentFlushPromise=null,(queue.length||pendingPostFlushCbs.length)&&flushJobs()}}let devtools,buffer=[];function setDevtoolsHook(hook,target){var _a,_b;devtools=hook,devtools?(devtools.enabled=!0,buffer.forEach(({event,args})=>devtools.emit(event,...args)),buffer=[]):typeof window<"u"&&window.HTMLElement&&!((_b=(_a=window.navigator)==null?void 0:_a.userAgent)!=null&&_b.includes("jsdom"))?((target.__VUE_DEVTOOLS_HOOK_REPLAY__=target.__VUE_DEVTOOLS_HOOK_REPLAY__||[]).push(newHook=>{setDevtoolsHook(newHook,target)}),setTimeout(()=>{devtools||(target.__VUE_DEVTOOLS_HOOK_REPLAY__=null,buffer=[])},3e3)):buffer=[]}function emit(instance,event,...rawArgs){if(instance.isUnmounted)return;const props=instance.vnode.props||EMPTY_OBJ;let args=rawArgs;const isModelListener2=event.startsWith("update:"),modelArg=isModelListener2&&event.slice(7);if(modelArg&&modelArg in props){const modifiersKey=`${modelArg==="modelValue"?"model":modelArg}Modifiers`,{number,trim}=props[modifiersKey]||EMPTY_OBJ;trim&&(args=rawArgs.map(a=>isString(a)?a.trim():a)),number&&(args=rawArgs.map(looseToNumber))}let handlerName,handler=props[handlerName=toHandlerKey(event)]||props[handlerName=toHandlerKey(camelize(event))];!handler&&isModelListener2&&(handler=props[handlerName=toHandlerKey(hyphenate(event))]),handler&&callWithAsyncErrorHandling(handler,instance,6,args);const onceHandler=props[handlerName+"Once"];if(onceHandler){if(!instance.emitted)instance.emitted={};else if(instance.emitted[handlerName])return;instance.emitted[handlerName]=!0,callWithAsyncErrorHandling(onceHandler,instance,6,args)}}function normalizeEmitsOptions(comp,appContext,asMixin=!1){const cache=appContext.emitsCache,cached=cache.get(comp);if(cached!==void 0)return cached;const raw=comp.emits;let normalized={},hasExtends=!1;if(!isFunction(comp)){const extendEmits=raw2=>{const normalizedFromExtend=normalizeEmitsOptions(raw2,appContext,!0);normalizedFromExtend&&(hasExtends=!0,extend(normalized,normalizedFromExtend))};!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendEmits),comp.extends&&extendEmits(comp.extends),comp.mixins&&comp.mixins.forEach(extendEmits)}return!raw&&!hasExtends?(isObject(comp)&&cache.set(comp,null),null):(isArray(raw)?raw.forEach(key=>normalized[key]=null):extend(normalized,raw),isObject(comp)&&cache.set(comp,normalized),normalized)}function isEmitListener(options,key){return!options||!isOn(key)?!1:(key=key.slice(2).replace(/Once$/,""),hasOwn(options,key[0].toLowerCase()+key.slice(1))||hasOwn(options,hyphenate(key))||hasOwn(options,key))}let currentRenderingInstance=null,currentScopeId=null;function setCurrentRenderingInstance(instance){const prev=currentRenderingInstance;return currentRenderingInstance=instance,currentScopeId=instance&&instance.type.__scopeId||null,prev}function pushScopeId(id){currentScopeId=id}function popScopeId(){currentScopeId=null}const withScopeId=_id=>withCtx;function withCtx(fn,ctx=currentRenderingInstance,isNonScopedSlot){if(!ctx||fn._n)return fn;const renderFnWithContext=(...args)=>{renderFnWithContext._d&&setBlockTracking(-1);const prevInstance=setCurrentRenderingInstance(ctx);let res;try{res=fn(...args)}finally{setCurrentRenderingInstance(prevInstance),renderFnWithContext._d&&setBlockTracking(1)}return res};return renderFnWithContext._n=!0,renderFnWithContext._c=!0,renderFnWithContext._d=!0,renderFnWithContext}function renderComponentRoot(instance){const{type:Component,vnode,proxy,withProxy,props,propsOptions:[propsOptions],slots,attrs,emit:emit2,render:render2,renderCache,data,setupState,ctx,inheritAttrs}=instance;let result,fallthroughAttrs;const prev=setCurrentRenderingInstance(instance);try{if(vnode.shapeFlag&4){const proxyToUse=withProxy||proxy,thisProxy=proxyToUse;result=normalizeVNode(render2.call(thisProxy,proxyToUse,renderCache,props,setupState,data,ctx)),fallthroughAttrs=attrs}else{const render22=Component;result=normalizeVNode(render22.length>1?render22(props,{attrs,slots,emit:emit2}):render22(props,null)),fallthroughAttrs=Component.props?attrs:getFunctionalFallthrough(attrs)}}catch(err){blockStack.length=0,handleError(err,instance,1),result=createVNode(Comment)}let root=result;if(fallthroughAttrs&&inheritAttrs!==!1){const keys=Object.keys(fallthroughAttrs),{shapeFlag}=root;keys.length&&shapeFlag&7&&(propsOptions&&keys.some(isModelListener)&&(fallthroughAttrs=filterModelListeners(fallthroughAttrs,propsOptions)),root=cloneVNode(root,fallthroughAttrs))}return vnode.dirs&&(root=cloneVNode(root),root.dirs=root.dirs?root.dirs.concat(vnode.dirs):vnode.dirs),vnode.transition&&(root.transition=vnode.transition),result=root,setCurrentRenderingInstance(prev),result}function filterSingleRoot(children){let singleRoot;for(let i=0;i<children.length;i++){const child=children[i];if(isVNode(child)){if(child.type!==Comment||child.children==="v-if"){if(singleRoot)return;singleRoot=child}}else return}return singleRoot}const getFunctionalFallthrough=attrs=>{let res;for(const key in attrs)(key==="class"||key==="style"||isOn(key))&&((res||(res={}))[key]=attrs[key]);return res},filterModelListeners=(attrs,props)=>{const res={};for(const key in attrs)(!isModelListener(key)||!(key.slice(9)in props))&&(res[key]=attrs[key]);return res};function shouldUpdateComponent(prevVNode,nextVNode,optimized){const{props:prevProps,children:prevChildren,component}=prevVNode,{props:nextProps,children:nextChildren,patchFlag}=nextVNode,emits=component.emitsOptions;if(nextVNode.dirs||nextVNode.transition)return!0;if(optimized&&patchFlag>=0){if(patchFlag&1024)return!0;if(patchFlag&16)return prevProps?hasPropsChanged(prevProps,nextProps,emits):!!nextProps;if(patchFlag&8){const dynamicProps=nextVNode.dynamicProps;for(let i=0;i<dynamicProps.length;i++){const key=dynamicProps[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emits,key))return!0}}}else return(prevChildren||nextChildren)&&(!nextChildren||!nextChildren.$stable)?!0:prevProps===nextProps?!1:prevProps?nextProps?hasPropsChanged(prevProps,nextProps,emits):!0:!!nextProps;return!1}function hasPropsChanged(prevProps,nextProps,emitsOptions){const nextKeys=Object.keys(nextProps);if(nextKeys.length!==Object.keys(prevProps).length)return!0;for(let i=0;i<nextKeys.length;i++){const key=nextKeys[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emitsOptions,key))return!0}return!1}function updateHOCHostEl({vnode,parent},el){for(;parent&&parent.subTree===vnode;)(vnode=parent.vnode).el=el,parent=parent.parent}const COMPONENTS="components",DIRECTIVES="directives";function resolveComponent(name,maybeSelfReference){return resolveAsset(COMPONENTS,name,!0,maybeSelfReference)||name}const NULL_DYNAMIC_COMPONENT=Symbol.for("v-ndc");function resolveDynamicComponent(component){return isString(component)?resolveAsset(COMPONENTS,component,!1)||component:component||NULL_DYNAMIC_COMPONENT}function resolveDirective(name){return resolveAsset(DIRECTIVES,name)}function resolveAsset(type,name,warnMissing=!0,maybeSelfReference=!1){const instance=currentRenderingInstance||currentInstance;if(instance){const Component=instance.type;if(type===COMPONENTS){const selfName=getComponentName(Component,!1);if(selfName&&(selfName===name||selfName===camelize(name)||selfName===capitalize(camelize(name))))return Component}const res=resolve(instance[type]||Component[type],name)||resolve(instance.appContext[type],name);return!res&&maybeSelfReference?Component:res}}function resolve(registry,name){return registry&&(registry[name]||registry[camelize(name)]||registry[capitalize(camelize(name))])}const isSuspense=type=>type.__isSuspense,SuspenseImpl={name:"Suspense",__isSuspense:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals){n1==null?mountSuspense(n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals):patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,slotScopeIds,optimized,rendererInternals)},hydrate:hydrateSuspense,create:createSuspenseBoundary,normalize:normalizeSuspenseChildren},Suspense=SuspenseImpl;function triggerEvent(vnode,name){const eventListener=vnode.props&&vnode.props[name];isFunction(eventListener)&&eventListener()}function mountSuspense(vnode,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals){const{p:patch,o:{createElement}}=rendererInternals,hiddenContainer=createElement("div"),suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,container,hiddenContainer,anchor,isSVG,slotScopeIds,optimized,rendererInternals);patch(null,suspense.pendingBranch=vnode.ssContent,hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds),suspense.deps>0?(triggerEvent(vnode,"onPending"),triggerEvent(vnode,"onFallback"),patch(null,vnode.ssFallback,container,anchor,parentComponent,null,isSVG,slotScopeIds),setActiveBranch(suspense,vnode.ssFallback)):suspense.resolve(!1,!0)}function patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,slotScopeIds,optimized,{p:patch,um:unmount,o:{createElement}}){const suspense=n2.suspense=n1.suspense;suspense.vnode=n2,n2.el=n1.el;const newBranch=n2.ssContent,newFallback=n2.ssFallback,{activeBranch,pendingBranch,isInFallback,isHydrating}=suspense;if(pendingBranch)suspense.pendingBranch=newBranch,isSameVNodeType(newBranch,pendingBranch)?(patch(pendingBranch,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0?suspense.resolve():isInFallback&&(patch(activeBranch,newFallback,container,anchor,parentComponent,null,isSVG,slotScopeIds,optimized),setActiveBranch(suspense,newFallback))):(suspense.pendingId++,isHydrating?(suspense.isHydrating=!1,suspense.activeBranch=pendingBranch):unmount(pendingBranch,parentComponent,suspense),suspense.deps=0,suspense.effects.length=0,suspense.hiddenContainer=createElement("div"),isInFallback?(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0?suspense.resolve():(patch(activeBranch,newFallback,container,anchor,parentComponent,null,isSVG,slotScopeIds,optimized),setActiveBranch(suspense,newFallback))):activeBranch&&isSameVNodeType(newBranch,activeBranch)?(patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.resolve(!0)):(patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0&&suspense.resolve()));else if(activeBranch&&isSameVNodeType(newBranch,activeBranch))patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,slotScopeIds,optimized),setActiveBranch(suspense,newBranch);else if(triggerEvent(n2,"onPending"),suspense.pendingBranch=newBranch,suspense.pendingId++,patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized),suspense.deps<=0)suspense.resolve();else{const{timeout,pendingId}=suspense;timeout>0?setTimeout(()=>{suspense.pendingId===pendingId&&suspense.fallback(newFallback)},timeout):timeout===0&&suspense.fallback(newFallback)}}function createSuspenseBoundary(vnode,parentSuspense,parentComponent,container,hiddenContainer,anchor,isSVG,slotScopeIds,optimized,rendererInternals,isHydrating=!1){const{p:patch,m:move,um:unmount,n:next,o:{parentNode,remove:remove2}}=rendererInternals;let parentSuspenseId;const isSuspensible=isVNodeSuspensible(vnode);isSuspensible&&parentSuspense!=null&&parentSuspense.pendingBranch&&(parentSuspenseId=parentSuspense.pendingId,parentSuspense.deps++);const timeout=vnode.props?toNumber(vnode.props.timeout):void 0,suspense={vnode,parent:parentSuspense,parentComponent,isSVG,container,hiddenContainer,anchor,deps:0,pendingId:0,timeout:typeof timeout=="number"?timeout:-1,activeBranch:null,pendingBranch:null,isInFallback:!0,isHydrating,isUnmounted:!1,effects:[],resolve(resume=!1,sync=!1){const{vnode:vnode2,activeBranch,pendingBranch,pendingId,effects,parentComponent:parentComponent2,container:container2}=suspense;let delayEnter=!1;if(suspense.isHydrating)suspense.isHydrating=!1;else if(!resume){delayEnter=activeBranch&&pendingBranch.transition&&pendingBranch.transition.mode==="out-in",delayEnter&&(activeBranch.transition.afterLeave=()=>{pendingId===suspense.pendingId&&(move(pendingBranch,container2,anchor2,0),queuePostFlushCb(effects))});let{anchor:anchor2}=suspense;activeBranch&&(anchor2=next(activeBranch),unmount(activeBranch,parentComponent2,suspense,!0)),delayEnter||move(pendingBranch,container2,anchor2,0)}setActiveBranch(suspense,pendingBranch),suspense.pendingBranch=null,suspense.isInFallback=!1;let parent=suspense.parent,hasUnresolvedAncestor=!1;for(;parent;){if(parent.pendingBranch){parent.effects.push(...effects),hasUnresolvedAncestor=!0;break}parent=parent.parent}!hasUnresolvedAncestor&&!delayEnter&&queuePostFlushCb(effects),suspense.effects=[],isSuspensible&&parentSuspense&&parentSuspense.pendingBranch&&parentSuspenseId===parentSuspense.pendingId&&(parentSuspense.deps--,parentSuspense.deps===0&&!sync&&parentSuspense.resolve()),triggerEvent(vnode2,"onResolve")},fallback(fallbackVNode){if(!suspense.pendingBranch)return;const{vnode:vnode2,activeBranch,parentComponent:parentComponent2,container:container2,isSVG:isSVG2}=suspense;triggerEvent(vnode2,"onFallback");const anchor2=next(activeBranch),mountFallback=()=>{suspense.isInFallback&&(patch(null,fallbackVNode,container2,anchor2,parentComponent2,null,isSVG2,slotScopeIds,optimized),setActiveBranch(suspense,fallbackVNode))},delayEnter=fallbackVNode.transition&&fallbackVNode.transition.mode==="out-in";delayEnter&&(activeBranch.transition.afterLeave=mountFallback),suspense.isInFallback=!0,unmount(activeBranch,parentComponent2,null,!0),delayEnter||mountFallback()},move(container2,anchor2,type){suspense.activeBranch&&move(suspense.activeBranch,container2,anchor2,type),suspense.container=container2},next(){return suspense.activeBranch&&next(suspense.activeBranch)},registerDep(instance,setupRenderEffect){const isInPendingSuspense=!!suspense.pendingBranch;isInPendingSuspense&&suspense.deps++;const hydratedEl=instance.vnode.el;instance.asyncDep.catch(err=>{handleError(err,instance,0)}).then(asyncSetupResult=>{if(instance.isUnmounted||suspense.isUnmounted||suspense.pendingId!==instance.suspenseId)return;instance.asyncResolved=!0;const{vnode:vnode2}=instance;handleSetupResult(instance,asyncSetupResult,!1),hydratedEl&&(vnode2.el=hydratedEl);const placeholder=!hydratedEl&&instance.subTree.el;setupRenderEffect(instance,vnode2,parentNode(hydratedEl||instance.subTree.el),hydratedEl?null:next(instance.subTree),suspense,isSVG,optimized),placeholder&&remove2(placeholder),updateHOCHostEl(instance,vnode2.el),isInPendingSuspense&&--suspense.deps===0&&suspense.resolve()})},unmount(parentSuspense2,doRemove){suspense.isUnmounted=!0,suspense.activeBranch&&unmount(suspense.activeBranch,parentComponent,parentSuspense2,doRemove),suspense.pendingBranch&&unmount(suspense.pendingBranch,parentComponent,parentSuspense2,doRemove)}};return suspense}function hydrateSuspense(node,vnode,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals,hydrateNode){const suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,node.parentNode,document.createElement("div"),null,isSVG,slotScopeIds,optimized,rendererInternals,!0),result=hydrateNode(node,suspense.pendingBranch=vnode.ssContent,parentComponent,suspense,slotScopeIds,optimized);return suspense.deps===0&&suspense.resolve(!1,!0),result}function normalizeSuspenseChildren(vnode){const{shapeFlag,children}=vnode,isSlotChildren=shapeFlag&32;vnode.ssContent=normalizeSuspenseSlot(isSlotChildren?children.default:children),vnode.ssFallback=isSlotChildren?normalizeSuspenseSlot(children.fallback):createVNode(Comment)}function normalizeSuspenseSlot(s){let block;if(isFunction(s)){const trackBlock=isBlockTreeEnabled&&s._c;trackBlock&&(s._d=!1,openBlock()),s=s(),trackBlock&&(s._d=!0,block=currentBlock,closeBlock())}return isArray(s)&&(s=filterSingleRoot(s)),s=normalizeVNode(s),block&&!s.dynamicChildren&&(s.dynamicChildren=block.filter(c=>c!==s)),s}function queueEffectWithSuspense(fn,suspense){suspense&&suspense.pendingBranch?isArray(fn)?suspense.effects.push(...fn):suspense.effects.push(fn):queuePostFlushCb(fn)}function setActiveBranch(suspense,branch){suspense.activeBranch=branch;const{vnode,parentComponent}=suspense,el=vnode.el=branch.el;parentComponent&&parentComponent.subTree===vnode&&(parentComponent.vnode.el=el,updateHOCHostEl(parentComponent,el))}function isVNodeSuspensible(vnode){var _a;return((_a=vnode.props)==null?void 0:_a.suspensible)!=null&&vnode.props.suspensible!==!1}function watchEffect(effect2,options){return doWatch(effect2,null,options)}function watchPostEffect(effect2,options){return doWatch(effect2,null,{flush:"post"})}function watchSyncEffect(effect2,options){return doWatch(effect2,null,{flush:"sync"})}const INITIAL_WATCHER_VALUE={};function watch(source,cb,options){return doWatch(source,cb,options)}function doWatch(source,cb,{immediate,deep,flush,onTrack,onTrigger}=EMPTY_OBJ){var _a;const instance=getCurrentScope()===((_a=currentInstance)==null?void 0:_a.scope)?currentInstance:null;let getter,forceTrigger=!1,isMultiSource=!1;if(isRef(source)?(getter=()=>source.value,forceTrigger=isShallow(source)):isReactive(source)?(getter=()=>source,deep=!0):isArray(source)?(isMultiSource=!0,forceTrigger=source.some(s=>isReactive(s)||isShallow(s)),getter=()=>source.map(s=>{if(isRef(s))return s.value;if(isReactive(s))return traverse(s);if(isFunction(s))return callWithErrorHandling(s,instance,2)})):isFunction(source)?cb?getter=()=>callWithErrorHandling(source,instance,2):getter=()=>{if(!(instance&&instance.isUnmounted))return cleanup&&cleanup(),callWithAsyncErrorHandling(source,instance,3,[onCleanup])}:getter=NOOP,cb&&deep){const baseGetter=getter;getter=()=>traverse(baseGetter())}let cleanup,onCleanup=fn=>{cleanup=effect2.onStop=()=>{callWithErrorHandling(fn,instance,4),cleanup=effect2.onStop=void 0}},ssrCleanup;if(isInSSRComponentSetup)if(onCleanup=NOOP,cb?immediate&&callWithAsyncErrorHandling(cb,instance,3,[getter(),isMultiSource?[]:void 0,onCleanup]):getter(),flush==="sync"){const ctx=useSSRContext();ssrCleanup=ctx.__watcherHandles||(ctx.__watcherHandles=[])}else return NOOP;let oldValue=isMultiSource?new Array(source.length).fill(INITIAL_WATCHER_VALUE):INITIAL_WATCHER_VALUE;const job=()=>{if(effect2.active)if(cb){const newValue=effect2.run();(deep||forceTrigger||(isMultiSource?newValue.some((v,i)=>hasChanged(v,oldValue[i])):hasChanged(newValue,oldValue)))&&(cleanup&&cleanup(),callWithAsyncErrorHandling(cb,instance,3,[newValue,oldValue===INITIAL_WATCHER_VALUE?void 0:isMultiSource&&oldValue[0]===INITIAL_WATCHER_VALUE?[]:oldValue,onCleanup]),oldValue=newValue)}else effect2.run()};job.allowRecurse=!!cb;let scheduler;flush==="sync"?scheduler=job:flush==="post"?scheduler=()=>queuePostRenderEffect(job,instance&&instance.suspense):(job.pre=!0,instance&&(job.id=instance.uid),scheduler=()=>queueJob(job));const effect2=new ReactiveEffect(getter,scheduler);cb?immediate?job():oldValue=effect2.run():flush==="post"?queuePostRenderEffect(effect2.run.bind(effect2),instance&&instance.suspense):effect2.run();const unwatch=()=>{effect2.stop(),instance&&instance.scope&&remove(instance.scope.effects,effect2)};return ssrCleanup&&ssrCleanup.push(unwatch),unwatch}function instanceWatch(source,value,options){const publicThis=this.proxy,getter=isString(source)?source.includes(".")?createPathGetter(publicThis,source):()=>publicThis[source]:source.bind(publicThis,publicThis);let cb;isFunction(value)?cb=value:(cb=value.handler,options=value);const cur=currentInstance;setCurrentInstance(this);const res=doWatch(getter,cb.bind(publicThis),options);return cur?setCurrentInstance(cur):unsetCurrentInstance(),res}function createPathGetter(ctx,path){const segments=path.split(".");return()=>{let cur=ctx;for(let i=0;i<segments.length&&cur;i++)cur=cur[segments[i]];return cur}}function traverse(value,seen2){if(!isObject(value)||value.__v_skip||(seen2=seen2||new Set,seen2.has(value)))return value;if(seen2.add(value),isRef(value))traverse(value.value,seen2);else if(isArray(value))for(let i=0;i<value.length;i++)traverse(value[i],seen2);else if(isSet(value)||isMap(value))value.forEach(v=>{traverse(v,seen2)});else if(isPlainObject(value))for(const key in value)traverse(value[key],seen2);return value}function withDirectives(vnode,directives){const internalInstance=currentRenderingInstance;if(internalInstance===null)return vnode;const instance=getExposeProxy(internalInstance)||internalInstance.proxy,bindings=vnode.dirs||(vnode.dirs=[]);for(let i=0;i<directives.length;i++){let[dir,value,arg,modifiers=EMPTY_OBJ]=directives[i];dir&&(isFunction(dir)&&(dir={mounted:dir,updated:dir}),dir.deep&&traverse(value),bindings.push({dir,instance,value,oldValue:void 0,arg,modifiers}))}return vnode}function invokeDirectiveHook(vnode,prevVNode,instance,name){const bindings=vnode.dirs,oldBindings=prevVNode&&prevVNode.dirs;for(let i=0;i<bindings.length;i++){const binding=bindings[i];oldBindings&&(binding.oldValue=oldBindings[i].value);let hook=binding.dir[name];hook&&(pauseTracking(),callWithAsyncErrorHandling(hook,instance,8,[vnode.el,binding,vnode,prevVNode]),resetTracking())}}const leaveCbKey=Symbol("_leaveCb"),enterCbKey$1=Symbol("_enterCb");function useTransitionState(){const state={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return onMounted(()=>{state.isMounted=!0}),onBeforeUnmount(()=>{state.isUnmounting=!0}),state}const TransitionHookValidator=[Function,Array],BaseTransitionPropsValidators={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:TransitionHookValidator,onEnter:TransitionHookValidator,onAfterEnter:TransitionHookValidator,onEnterCancelled:TransitionHookValidator,onBeforeLeave:TransitionHookValidator,onLeave:TransitionHookValidator,onAfterLeave:TransitionHookValidator,onLeaveCancelled:TransitionHookValidator,onBeforeAppear:TransitionHookValidator,onAppear:TransitionHookValidator,onAfterAppear:TransitionHookValidator,onAppearCancelled:TransitionHookValidator},BaseTransitionImpl={name:"BaseTransition",props:BaseTransitionPropsValidators,setup(props,{slots}){const instance=getCurrentInstance(),state=useTransitionState();let prevTransitionKey;return()=>{const children=slots.default&&getTransitionRawChildren(slots.default(),!0);if(!children||!children.length)return;let child=children[0];if(children.length>1){for(const c of children)if(c.type!==Comment){child=c;break}}const rawProps=toRaw(props),{mode}=rawProps;if(state.isLeaving)return emptyPlaceholder(child);const innerChild=getKeepAliveChild(child);if(!innerChild)return emptyPlaceholder(child);const enterHooks=resolveTransitionHooks(innerChild,rawProps,state,instance);setTransitionHooks(innerChild,enterHooks);const oldChild=instance.subTree,oldInnerChild=oldChild&&getKeepAliveChild(oldChild);let transitionKeyChanged=!1;const{getTransitionKey}=innerChild.type;if(getTransitionKey){const key=getTransitionKey();prevTransitionKey===void 0?prevTransitionKey=key:key!==prevTransitionKey&&(prevTransitionKey=key,transitionKeyChanged=!0)}if(oldInnerChild&&oldInnerChild.type!==Comment&&(!isSameVNodeType(innerChild,oldInnerChild)||transitionKeyChanged)){const leavingHooks=resolveTransitionHooks(oldInnerChild,rawProps,state,instance);if(setTransitionHooks(oldInnerChild,leavingHooks),mode==="out-in")return state.isLeaving=!0,leavingHooks.afterLeave=()=>{state.isLeaving=!1,instance.update.active!==!1&&instance.update()},emptyPlaceholder(child);mode==="in-out"&&innerChild.type!==Comment&&(leavingHooks.delayLeave=(el,earlyRemove,delayedLeave)=>{const leavingVNodesCache=getLeavingNodesForType(state,oldInnerChild);leavingVNodesCache[String(oldInnerChild.key)]=oldInnerChild,el[leaveCbKey]=()=>{earlyRemove(),el[leaveCbKey]=void 0,delete enterHooks.delayedLeave},enterHooks.delayedLeave=delayedLeave})}return child}}},BaseTransition=BaseTransitionImpl;function getLeavingNodesForType(state,vnode){const{leavingVNodes}=state;let leavingVNodesCache=leavingVNodes.get(vnode.type);return leavingVNodesCache||(leavingVNodesCache=Object.create(null),leavingVNodes.set(vnode.type,leavingVNodesCache)),leavingVNodesCache}function resolveTransitionHooks(vnode,props,state,instance){const{appear,mode,persisted=!1,onBeforeEnter,onEnter,onAfterEnter,onEnterCancelled,onBeforeLeave,onLeave,onAfterLeave,onLeaveCancelled,onBeforeAppear,onAppear,onAfterAppear,onAppearCancelled}=props,key=String(vnode.key),leavingVNodesCache=getLeavingNodesForType(state,vnode),callHook2=(hook,args)=>{hook&&callWithAsyncErrorHandling(hook,instance,9,args)},callAsyncHook=(hook,args)=>{const done=args[1];callHook2(hook,args),isArray(hook)?hook.every(hook2=>hook2.length<=1)&&done():hook.length<=1&&done()},hooks={mode,persisted,beforeEnter(el){let hook=onBeforeEnter;if(!state.isMounted)if(appear)hook=onBeforeAppear||onBeforeEnter;else return;el[leaveCbKey]&&el[leaveCbKey](!0);const leavingVNode=leavingVNodesCache[key];leavingVNode&&isSameVNodeType(vnode,leavingVNode)&&leavingVNode.el[leaveCbKey]&&leavingVNode.el[leaveCbKey](),callHook2(hook,[el])},enter(el){let hook=onEnter,afterHook=onAfterEnter,cancelHook=onEnterCancelled;if(!state.isMounted)if(appear)hook=onAppear||onEnter,afterHook=onAfterAppear||onAfterEnter,cancelHook=onAppearCancelled||onEnterCancelled;else return;let called=!1;const done=el[enterCbKey$1]=cancelled=>{called||(called=!0,cancelled?callHook2(cancelHook,[el]):callHook2(afterHook,[el]),hooks.delayedLeave&&hooks.delayedLeave(),el[enterCbKey$1]=void 0)};hook?callAsyncHook(hook,[el,done]):done()},leave(el,remove2){const key2=String(vnode.key);if(el[enterCbKey$1]&&el[enterCbKey$1](!0),state.isUnmounting)return remove2();callHook2(onBeforeLeave,[el]);let called=!1;const done=el[leaveCbKey]=cancelled=>{called||(called=!0,remove2(),cancelled?callHook2(onLeaveCancelled,[el]):callHook2(onAfterLeave,[el]),el[leaveCbKey]=void 0,leavingVNodesCache[key2]===vnode&&delete leavingVNodesCache[key2])};leavingVNodesCache[key2]=vnode,onLeave?callAsyncHook(onLeave,[el,done]):done()},clone(vnode2){return resolveTransitionHooks(vnode2,props,state,instance)}};return hooks}function emptyPlaceholder(vnode){if(isKeepAlive(vnode))return vnode=cloneVNode(vnode),vnode.children=null,vnode}function getKeepAliveChild(vnode){return isKeepAlive(vnode)?vnode.children?vnode.children[0]:void 0:vnode}function setTransitionHooks(vnode,hooks){vnode.shapeFlag&6&&vnode.component?setTransitionHooks(vnode.component.subTree,hooks):vnode.shapeFlag&128?(vnode.ssContent.transition=hooks.clone(vnode.ssContent),vnode.ssFallback.transition=hooks.clone(vnode.ssFallback)):vnode.transition=hooks}function getTransitionRawChildren(children,keepComment=!1,parentKey){let ret=[],keyedFragmentCount=0;for(let i=0;i<children.length;i++){let child=children[i];const key=parentKey==null?child.key:String(parentKey)+String(child.key!=null?child.key:i);child.type===Fragment?(child.patchFlag&128&&keyedFragmentCount++,ret=ret.concat(getTransitionRawChildren(child.children,keepComment,key))):(keepComment||child.type!==Comment)&&ret.push(key!=null?cloneVNode(child,{key}):child)}if(keyedFragmentCount>1)for(let i=0;i<ret.length;i++)ret[i].patchFlag=-2;return ret}/*! #__NO_SIDE_EFFECTS__ */function defineComponent(options,extraOptions){return isFunction(options)?extend({name:options.name},extraOptions,{setup:options}):options}const isAsyncWrapper=i=>!!i.type.__asyncLoader;/*! #__NO_SIDE_EFFECTS__ */function defineAsyncComponent(source){isFunction(source)&&(source={loader:source});const{loader,loadingComponent,errorComponent,delay=200,timeout,suspensible=!0,onError:userOnError}=source;let pendingRequest=null,resolvedComp,retries=0;const retry=()=>(retries++,pendingRequest=null,load()),load=()=>{let thisRequest;return pendingRequest||(thisRequest=pendingRequest=loader().catch(err=>{if(err=err instanceof Error?err:new Error(String(err)),userOnError)return new Promise((resolve2,reject)=>{userOnError(err,()=>resolve2(retry()),()=>reject(err),retries+1)});throw err}).then(comp=>thisRequest!==pendingRequest&&pendingRequest?pendingRequest:(comp&&(comp.__esModule||comp[Symbol.toStringTag]==="Module")&&(comp=comp.default),resolvedComp=comp,comp)))};return defineComponent({name:"AsyncComponentWrapper",__asyncLoader:load,get __asyncResolved(){return resolvedComp},setup(){const instance=currentInstance;if(resolvedComp)return()=>createInnerComp(resolvedComp,instance);const onError=err=>{pendingRequest=null,handleError(err,instance,13,!errorComponent)};if(suspensible&&instance.suspense||isInSSRComponentSetup)return load().then(comp=>()=>createInnerComp(comp,instance)).catch(err=>(onError(err),()=>errorComponent?createVNode(errorComponent,{error:err}):null));const loaded=ref(!1),error=ref(),delayed=ref(!!delay);return delay&&setTimeout(()=>{delayed.value=!1},delay),timeout!=null&&setTimeout(()=>{if(!loaded.value&&!error.value){const err=new Error(`Async component timed out after ${timeout}ms.`);onError(err),error.value=err}},timeout),load().then(()=>{loaded.value=!0,instance.parent&&isKeepAlive(instance.parent.vnode)&&queueJob(instance.parent.update)}).catch(err=>{onError(err),error.value=err}),()=>{if(loaded.value&&resolvedComp)return createInnerComp(resolvedComp,instance);if(error.value&&errorComponent)return createVNode(errorComponent,{error:error.value});if(loadingComponent&&!delayed.value)return createVNode(loadingComponent)}}})}function createInnerComp(comp,parent){const{ref:ref22,props,children,ce}=parent.vnode,vnode=createVNode(comp,props,children);return vnode.ref=ref22,vnode.ce=ce,delete parent.vnode.ce,vnode}const isKeepAlive=vnode=>vnode.type.__isKeepAlive,KeepAliveImpl={name:"KeepAlive",__isKeepAlive:!0,props:{include:[String,RegExp,Array],exclude:[String,RegExp,Array],max:[String,Number]},setup(props,{slots}){const instance=getCurrentInstance(),sharedContext=instance.ctx;if(!sharedContext.renderer)return()=>{const children=slots.default&&slots.default();return children&&children.length===1?children[0]:children};const cache=new Map,keys=new Set;let current=null;const parentSuspense=instance.suspense,{renderer:{p:patch,m:move,um:_unmount,o:{createElement}}}=sharedContext,storageContainer=createElement("div");sharedContext.activate=(vnode,container,anchor,isSVG,optimized)=>{const instance2=vnode.component;move(vnode,container,anchor,0,parentSuspense),patch(instance2.vnode,vnode,container,anchor,instance2,parentSuspense,isSVG,vnode.slotScopeIds,optimized),queuePostRenderEffect(()=>{instance2.isDeactivated=!1,instance2.a&&invokeArrayFns(instance2.a);const vnodeHook=vnode.props&&vnode.props.onVnodeMounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance2.parent,vnode)},parentSuspense)},sharedContext.deactivate=vnode=>{const instance2=vnode.component;move(vnode,storageContainer,null,1,parentSuspense),queuePostRenderEffect(()=>{instance2.da&&invokeArrayFns(instance2.da);const vnodeHook=vnode.props&&vnode.props.onVnodeUnmounted;vnodeHook&&invokeVNodeHook(vnodeHook,instance2.parent,vnode),instance2.isDeactivated=!0},parentSuspense)};function unmount(vnode){resetShapeFlag(vnode),_unmount(vnode,instance,parentSuspense,!0)}function pruneCache(filter){cache.forEach((vnode,key)=>{const name=getComponentName(vnode.type);name&&(!filter||!filter(name))&&pruneCacheEntry(key)})}function pruneCacheEntry(key){const cached=cache.get(key);!current||!isSameVNodeType(cached,current)?unmount(cached):current&&resetShapeFlag(current),cache.delete(key),keys.delete(key)}watch(()=>[props.include,props.exclude],([include,exclude])=>{include&&pruneCache(name=>matches(include,name)),exclude&&pruneCache(name=>!matches(exclude,name))},{flush:"post",deep:!0});let pendingCacheKey=null;const cacheSubtree=()=>{pendingCacheKey!=null&&cache.set(pendingCacheKey,getInnerChild(instance.subTree))};return onMounted(cacheSubtree),onUpdated(cacheSubtree),onBeforeUnmount(()=>{cache.forEach(cached=>{const{subTree,suspense}=instance,vnode=getInnerChild(subTree);if(cached.type===vnode.type&&cached.key===vnode.key){resetShapeFlag(vnode);const da=vnode.component.da;da&&queuePostRenderEffect(da,suspense);return}unmount(cached)})}),()=>{if(pendingCacheKey=null,!slots.default)return null;const children=slots.default(),rawVNode=children[0];if(children.length>1)return current=null,children;if(!isVNode(rawVNode)||!(rawVNode.shapeFlag&4)&&!(rawVNode.shapeFlag&128))return current=null,rawVNode;let vnode=getInnerChild(rawVNode);const comp=vnode.type,name=getComponentName(isAsyncWrapper(vnode)?vnode.type.__asyncResolved||{}:comp),{include,exclude,max}=props;if(include&&(!name||!matches(include,name))||exclude&&name&&matches(exclude,name))return current=vnode,rawVNode;const key=vnode.key==null?comp:vnode.key,cachedVNode=cache.get(key);return vnode.el&&(vnode=cloneVNode(vnode),rawVNode.shapeFlag&128&&(rawVNode.ssContent=vnode)),pendingCacheKey=key,cachedVNode?(vnode.el=cachedVNode.el,vnode.component=cachedVNode.component,vnode.transition&&setTransitionHooks(vnode,vnode.transition),vnode.shapeFlag|=512,keys.delete(key),keys.add(key)):(keys.add(key),max&&keys.size>parseInt(max,10)&&pruneCacheEntry(keys.values().next().value)),vnode.shapeFlag|=256,current=vnode,isSuspense(rawVNode.type)?rawVNode:vnode}}},KeepAlive=KeepAliveImpl;function matches(pattern,name){return isArray(pattern)?pattern.some(p2=>matches(p2,name)):isString(pattern)?pattern.split(",").includes(name):isRegExp(pattern)?pattern.test(name):!1}function onActivated(hook,target){registerKeepAliveHook(hook,"a",target)}function onDeactivated(hook,target){registerKeepAliveHook(hook,"da",target)}function registerKeepAliveHook(hook,type,target=currentInstance){const wrappedHook=hook.__wdc||(hook.__wdc=()=>{let current=target;for(;current;){if(current.isDeactivated)return;current=current.parent}return hook()});if(injectHook(type,wrappedHook,target),target){let current=target.parent;for(;current&&current.parent;)isKeepAlive(current.parent.vnode)&&injectToKeepAliveRoot(wrappedHook,type,target,current),current=current.parent}}function injectToKeepAliveRoot(hook,type,target,keepAliveRoot){const injected=injectHook(type,hook,keepAliveRoot,!0);onUnmounted(()=>{remove(keepAliveRoot[type],injected)},target)}function resetShapeFlag(vnode){vnode.shapeFlag&=-257,vnode.shapeFlag&=-513}function getInnerChild(vnode){return vnode.shapeFlag&128?vnode.ssContent:vnode}function injectHook(type,hook,target=currentInstance,prepend=!1){if(target){const hooks=target[type]||(target[type]=[]),wrappedHook=hook.__weh||(hook.__weh=(...args)=>{if(target.isUnmounted)return;pauseTracking(),setCurrentInstance(target);const res=callWithAsyncErrorHandling(hook,target,type,args);return unsetCurrentInstance(),resetTracking(),res});return prepend?hooks.unshift(wrappedHook):hooks.push(wrappedHook),wrappedHook}}const createHook=lifecycle=>(hook,target=currentInstance)=>(!isInSSRComponentSetup||lifecycle==="sp")&&injectHook(lifecycle,(...args)=>hook(...args),target),onBeforeMount=createHook("bm"),onMounted=createHook("m"),onBeforeUpdate=createHook("bu"),onUpdated=createHook("u"),onBeforeUnmount=createHook("bum"),onUnmounted=createHook("um"),onServerPrefetch=createHook("sp"),onRenderTriggered=createHook("rtg"),onRenderTracked=createHook("rtc");function onErrorCaptured(hook,target=currentInstance){injectHook("ec",hook,target)}function renderList(source,renderItem,cache,index){let ret;const cached=cache&&cache[index];if(isArray(source)||isString(source)){ret=new Array(source.length);for(let i=0,l=source.length;i<l;i++)ret[i]=renderItem(source[i],i,void 0,cached&&cached[i])}else if(typeof source=="number"){ret=new Array(source);for(let i=0;i<source;i++)ret[i]=renderItem(i+1,i,void 0,cached&&cached[i])}else if(isObject(source))if(source[Symbol.iterator])ret=Array.from(source,(item,i)=>renderItem(item,i,void 0,cached&&cached[i]));else{const keys=Object.keys(source);ret=new Array(keys.length);for(let i=0,l=keys.length;i<l;i++){const key=keys[i];ret[i]=renderItem(source[key],key,i,cached&&cached[i])}}else ret=[];return cache&&(cache[index]=ret),ret}function createSlots(slots,dynamicSlots){for(let i=0;i<dynamicSlots.length;i++){const slot=dynamicSlots[i];if(isArray(slot))for(let j=0;j<slot.length;j++)slots[slot[j].name]=slot[j].fn;else slot&&(slots[slot.name]=slot.key?(...args)=>{const res=slot.fn(...args);return res&&(res.key=slot.key),res}:slot.fn)}return slots}function renderSlot(slots,name,props={},fallback,noSlotted){if(currentRenderingInstance.isCE||currentRenderingInstance.parent&&isAsyncWrapper(currentRenderingInstance.parent)&&currentRenderingInstance.parent.isCE)return name!=="default"&&(props.name=name),createVNode("slot",props,fallback&&fallback());let slot=slots[name];slot&&slot._c&&(slot._d=!1),openBlock();const validSlotContent=slot&&ensureValidVNode(slot(props)),rendered=createBlock(Fragment,{key:props.key||validSlotContent&&validSlotContent.key||`_${name}`},validSlotContent||(fallback?fallback():[]),validSlotContent&&slots._===1?64:-2);return!noSlotted&&rendered.scopeId&&(rendered.slotScopeIds=[rendered.scopeId+"-s"]),slot&&slot._c&&(slot._d=!0),rendered}function ensureValidVNode(vnodes){return vnodes.some(child=>isVNode(child)?!(child.type===Comment||child.type===Fragment&&!ensureValidVNode(child.children)):!0)?vnodes:null}function toHandlers(obj,preserveCaseIfNecessary){const ret={};for(const key in obj)ret[preserveCaseIfNecessary&&/[A-Z]/.test(key)?`on:${key}`:toHandlerKey(key)]=obj[key];return ret}const getPublicInstance=i=>i?isStatefulComponent(i)?getExposeProxy(i)||i.proxy:getPublicInstance(i.parent):null,publicPropertiesMap=extend(Object.create(null),{$:i=>i,$el:i=>i.vnode.el,$data:i=>i.data,$props:i=>i.props,$attrs:i=>i.attrs,$slots:i=>i.slots,$refs:i=>i.refs,$parent:i=>getPublicInstance(i.parent),$root:i=>getPublicInstance(i.root),$emit:i=>i.emit,$options:i=>resolveMergedOptions(i),$forceUpdate:i=>i.f||(i.f=()=>queueJob(i.update)),$nextTick:i=>i.n||(i.n=nextTick.bind(i.proxy)),$watch:i=>instanceWatch.bind(i)}),hasSetupBinding=(state,key)=>state!==EMPTY_OBJ&&!state.__isScriptSetup&&hasOwn(state,key),PublicInstanceProxyHandlers={get({_:instance},key){const{ctx,setupState,data,props,accessCache,type,appContext}=instance;let normalizedProps;if(key[0]!=="$"){const n=accessCache[key];if(n!==void 0)switch(n){case 1:return setupState[key];case 2:return data[key];case 4:return ctx[key];case 3:return props[key]}else{if(hasSetupBinding(setupState,key))return accessCache[key]=1,setupState[key];if(data!==EMPTY_OBJ&&hasOwn(data,key))return accessCache[key]=2,data[key];if((normalizedProps=instance.propsOptions[0])&&hasOwn(normalizedProps,key))return accessCache[key]=3,props[key];if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key))return accessCache[key]=4,ctx[key];shouldCacheAccess&&(accessCache[key]=0)}}const publicGetter=publicPropertiesMap[key];let cssModule,globalProperties;if(publicGetter)return key==="$attrs"&&track(instance,"get",key),publicGetter(instance);if((cssModule=type.__cssModules)&&(cssModule=cssModule[key]))return cssModule;if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key))return accessCache[key]=4,ctx[key];if(globalProperties=appContext.config.globalProperties,hasOwn(globalProperties,key))return globalProperties[key]},set({_:instance},key,value){const{data,setupState,ctx}=instance;return hasSetupBinding(setupState,key)?(setupState[key]=value,!0):data!==EMPTY_OBJ&&hasOwn(data,key)?(data[key]=value,!0):hasOwn(instance.props,key)||key[0]==="$"&&key.slice(1)in instance?!1:(ctx[key]=value,!0)},has({_:{data,setupState,accessCache,ctx,appContext,propsOptions}},key){let normalizedProps;return!!accessCache[key]||data!==EMPTY_OBJ&&hasOwn(data,key)||hasSetupBinding(setupState,key)||(normalizedProps=propsOptions[0])&&hasOwn(normalizedProps,key)||hasOwn(ctx,key)||hasOwn(publicPropertiesMap,key)||hasOwn(appContext.config.globalProperties,key)},defineProperty(target,key,descriptor){return descriptor.get!=null?target._.accessCache[key]=0:hasOwn(descriptor,"value")&&this.set(target,key,descriptor.value,null),Reflect.defineProperty(target,key,descriptor)}},RuntimeCompiledPublicInstanceProxyHandlers=extend({},PublicInstanceProxyHandlers,{get(target,key){if(key!==Symbol.unscopables)return PublicInstanceProxyHandlers.get(target,key,target)},has(_,key){return key[0]!=="_"&&!isGloballyAllowed(key)}});function defineProps(){return null}function defineEmits(){return null}function defineExpose(exposed){}function defineOptions(options){}function defineSlots(){return null}function defineModel(){}function withDefaults(props,defaults){return null}function useSlots(){return getContext().slots}function useAttrs(){return getContext().attrs}function useModel(props,name,options){const i=getCurrentInstance();if(options&&options.local){const proxy=ref(props[name]);return watch(()=>props[name],v=>proxy.value=v),watch(proxy,value=>{value!==props[name]&&i.emit(`update:${name}`,value)}),proxy}else return{__v_isRef:!0,get value(){return props[name]},set value(value){i.emit(`update:${name}`,value)}}}function getContext(){const i=getCurrentInstance();return i.setupContext||(i.setupContext=createSetupContext(i))}function normalizePropsOrEmits(props){return isArray(props)?props.reduce((normalized,p2)=>(normalized[p2]=null,normalized),{}):props}function mergeDefaults(raw,defaults){const props=normalizePropsOrEmits(raw);for(const key in defaults){if(key.startsWith("__skip"))continue;let opt=props[key];opt?isArray(opt)||isFunction(opt)?opt=props[key]={type:opt,default:defaults[key]}:opt.default=defaults[key]:opt===null&&(opt=props[key]={default:defaults[key]}),opt&&defaults[`__skip_${key}`]&&(opt.skipFactory=!0)}return props}function mergeModels(a,b){return!a||!b?a||b:isArray(a)&&isArray(b)?a.concat(b):extend({},normalizePropsOrEmits(a),normalizePropsOrEmits(b))}function createPropsRestProxy(props,excludedKeys){const ret={};for(const key in props)excludedKeys.includes(key)||Object.defineProperty(ret,key,{enumerable:!0,get:()=>props[key]});return ret}function withAsyncContext(getAwaitable){const ctx=getCurrentInstance();let awaitable=getAwaitable();return unsetCurrentInstance(),isPromise(awaitable)&&(awaitable=awaitable.catch(e=>{throw setCurrentInstance(ctx),e})),[awaitable,()=>setCurrentInstance(ctx)]}let shouldCacheAccess=!0;function applyOptions(instance){const options=resolveMergedOptions(instance),publicThis=instance.proxy,ctx=instance.ctx;shouldCacheAccess=!1,options.beforeCreate&&callHook$1(options.beforeCreate,instance,"bc");const{data:dataOptions,computed:computedOptions,methods,watch:watchOptions,provide:provideOptions,inject:injectOptions,created,beforeMount,mounted,beforeUpdate,updated,activated,deactivated,beforeDestroy,beforeUnmount,destroyed,unmounted,render:render2,renderTracked,renderTriggered,errorCaptured,serverPrefetch,expose,inheritAttrs,components,directives,filters}=options;if(injectOptions&&resolveInjections(injectOptions,ctx,null),methods)for(const key in methods){const methodHandler=methods[key];isFunction(methodHandler)&&(ctx[key]=methodHandler.bind(publicThis))}if(dataOptions){const data=dataOptions.call(publicThis,publicThis);isObject(data)&&(instance.data=reactive(data))}if(shouldCacheAccess=!0,computedOptions)for(const key in computedOptions){const opt=computedOptions[key],get2=isFunction(opt)?opt.bind(publicThis,publicThis):isFunction(opt.get)?opt.get.bind(publicThis,publicThis):NOOP,set2=!isFunction(opt)&&isFunction(opt.set)?opt.set.bind(publicThis):NOOP,c=computed({get:get2,set:set2});Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>c.value,set:v=>c.value=v})}if(watchOptions)for(const key in watchOptions)createWatcher(watchOptions[key],ctx,publicThis,key);if(provideOptions){const provides=isFunction(provideOptions)?provideOptions.call(publicThis):provideOptions;Reflect.ownKeys(provides).forEach(key=>{provide(key,provides[key])})}created&&callHook$1(created,instance,"c");function registerLifecycleHook(register,hook){isArray(hook)?hook.forEach(_hook=>register(_hook.bind(publicThis))):hook&&register(hook.bind(publicThis))}if(registerLifecycleHook(onBeforeMount,beforeMount),registerLifecycleHook(onMounted,mounted),registerLifecycleHook(onBeforeUpdate,beforeUpdate),registerLifecycleHook(onUpdated,updated),registerLifecycleHook(onActivated,activated),registerLifecycleHook(onDeactivated,deactivated),registerLifecycleHook(onErrorCaptured,errorCaptured),registerLifecycleHook(onRenderTracked,renderTracked),registerLifecycleHook(onRenderTriggered,renderTriggered),registerLifecycleHook(onBeforeUnmount,beforeUnmount),registerLifecycleHook(onUnmounted,unmounted),registerLifecycleHook(onServerPrefetch,serverPrefetch),isArray(expose))if(expose.length){const exposed=instance.exposed||(instance.exposed={});expose.forEach(key=>{Object.defineProperty(exposed,key,{get:()=>publicThis[key],set:val=>publicThis[key]=val})})}else instance.exposed||(instance.exposed={});render2&&instance.render===NOOP&&(instance.render=render2),inheritAttrs!=null&&(instance.inheritAttrs=inheritAttrs),components&&(instance.components=components),directives&&(instance.directives=directives)}function resolveInjections(injectOptions,ctx,checkDuplicateProperties=NOOP){isArray(injectOptions)&&(injectOptions=normalizeInject(injectOptions));for(const key in injectOptions){const opt=injectOptions[key];let injected;isObject(opt)?"default"in opt?injected=inject(opt.from||key,opt.default,!0):injected=inject(opt.from||key):injected=inject(opt),isRef(injected)?Object.defineProperty(ctx,key,{enumerable:!0,configurable:!0,get:()=>injected.value,set:v=>injected.value=v}):ctx[key]=injected}}function callHook$1(hook,instance,type){callWithAsyncErrorHandling(isArray(hook)?hook.map(h2=>h2.bind(instance.proxy)):hook.bind(instance.proxy),instance,type)}function createWatcher(raw,ctx,publicThis,key){const getter=key.includes(".")?createPathGetter(publicThis,key):()=>publicThis[key];if(isString(raw)){const handler=ctx[raw];isFunction(handler)&&watch(getter,handler)}else if(isFunction(raw))watch(getter,raw.bind(publicThis));else if(isObject(raw))if(isArray(raw))raw.forEach(r=>createWatcher(r,ctx,publicThis,key));else{const handler=isFunction(raw.handler)?raw.handler.bind(publicThis):ctx[raw.handler];isFunction(handler)&&watch(getter,handler,raw)}}function resolveMergedOptions(instance){const base=instance.type,{mixins,extends:extendsOptions}=base,{mixins:globalMixins,optionsCache:cache,config:{optionMergeStrategies}}=instance.appContext,cached=cache.get(base);let resolved;return cached?resolved=cached:!globalMixins.length&&!mixins&&!extendsOptions?resolved=base:(resolved={},globalMixins.length&&globalMixins.forEach(m=>mergeOptions(resolved,m,optionMergeStrategies,!0)),mergeOptions(resolved,base,optionMergeStrategies)),isObject(base)&&cache.set(base,resolved),resolved}function mergeOptions(to,from,strats,asMixin=!1){const{mixins,extends:extendsOptions}=from;extendsOptions&&mergeOptions(to,extendsOptions,strats,!0),mixins&&mixins.forEach(m=>mergeOptions(to,m,strats,!0));for(const key in from)if(!(asMixin&&key==="expose")){const strat=internalOptionMergeStrats[key]||strats&&strats[key];to[key]=strat?strat(to[key],from[key]):from[key]}return to}const internalOptionMergeStrats={data:mergeDataFn,props:mergeEmitsOrPropsOptions,emits:mergeEmitsOrPropsOptions,methods:mergeObjectOptions,computed:mergeObjectOptions,beforeCreate:mergeAsArray$1,created:mergeAsArray$1,beforeMount:mergeAsArray$1,mounted:mergeAsArray$1,beforeUpdate:mergeAsArray$1,updated:mergeAsArray$1,beforeDestroy:mergeAsArray$1,beforeUnmount:mergeAsArray$1,destroyed:mergeAsArray$1,unmounted:mergeAsArray$1,activated:mergeAsArray$1,deactivated:mergeAsArray$1,errorCaptured:mergeAsArray$1,serverPrefetch:mergeAsArray$1,components:mergeObjectOptions,directives:mergeObjectOptions,watch:mergeWatchOptions,provide:mergeDataFn,inject:mergeInject};function mergeDataFn(to,from){return from?to?function(){return extend(isFunction(to)?to.call(this,this):to,isFunction(from)?from.call(this,this):from)}:from:to}function mergeInject(to,from){return mergeObjectOptions(normalizeInject(to),normalizeInject(from))}function normalizeInject(raw){if(isArray(raw)){const res={};for(let i=0;i<raw.length;i++)res[raw[i]]=raw[i];return res}return raw}function mergeAsArray$1(to,from){return to?[...new Set([].concat(to,from))]:from}function mergeObjectOptions(to,from){return to?extend(Object.create(null),to,from):from}function mergeEmitsOrPropsOptions(to,from){return to?isArray(to)&&isArray(from)?[...new Set([...to,...from])]:extend(Object.create(null),normalizePropsOrEmits(to),normalizePropsOrEmits(from??{})):from}function mergeWatchOptions(to,from){if(!to)return from;if(!from)return to;const merged=extend(Object.create(null),to);for(const key in from)merged[key]=mergeAsArray$1(to[key],from[key]);return merged}function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let uid$1=0;function createAppAPI(render2,hydrate2){return function(rootComponent,rootProps=null){isFunction(rootComponent)||(rootComponent=extend({},rootComponent)),rootProps!=null&&!isObject(rootProps)&&(rootProps=null);const context=createAppContext(),installedPlugins=new WeakSet;let isMounted=!1;const app=context.app={_uid:uid$1++,_component:rootComponent,_props:rootProps,_container:null,_context:context,_instance:null,version,get config(){return context.config},set config(v){},use(plugin,...options){return installedPlugins.has(plugin)||(plugin&&isFunction(plugin.install)?(installedPlugins.add(plugin),plugin.install(app,...options)):isFunction(plugin)&&(installedPlugins.add(plugin),plugin(app,...options))),app},mixin(mixin){return context.mixins.includes(mixin)||context.mixins.push(mixin),app},component(name,component){return component?(context.components[name]=component,app):context.components[name]},directive(name,directive){return directive?(context.directives[name]=directive,app):context.directives[name]},mount(rootContainer,isHydrate,isSVG){if(!isMounted){const vnode=createVNode(rootComponent,rootProps);return vnode.appContext=context,isHydrate&&hydrate2?hydrate2(vnode,rootContainer):render2(vnode,rootContainer,isSVG),isMounted=!0,app._container=rootContainer,rootContainer.__vue_app__=app,getExposeProxy(vnode.component)||vnode.component.proxy}},unmount(){isMounted&&(render2(null,app._container),delete app._container.__vue_app__)},provide(key,value){return context.provides[key]=value,app},runWithContext(fn){currentApp=app;try{return fn()}finally{currentApp=null}}};return app}}let currentApp=null;function provide(key,value){if(currentInstance){let provides=currentInstance.provides;const parentProvides=currentInstance.parent&&currentInstance.parent.provides;parentProvides===provides&&(provides=currentInstance.provides=Object.create(parentProvides)),provides[key]=value}}function inject(key,defaultValue,treatDefaultAsFactory=!1){const instance=currentInstance||currentRenderingInstance;if(instance||currentApp){const provides=instance?instance.parent==null?instance.vnode.appContext&&instance.vnode.appContext.provides:instance.parent.provides:currentApp._context.provides;if(provides&&key in provides)return provides[key];if(arguments.length>1)return treatDefaultAsFactory&&isFunction(defaultValue)?defaultValue.call(instance&&instance.proxy):defaultValue}}function hasInjectionContext(){return!!(currentInstance||currentRenderingInstance||currentApp)}function initProps(instance,rawProps,isStateful,isSSR=!1){const props={},attrs={};def(attrs,InternalObjectKey,1),instance.propsDefaults=Object.create(null),setFullProps(instance,rawProps,props,attrs);for(const key in instance.propsOptions[0])key in props||(props[key]=void 0);isStateful?instance.props=isSSR?props:shallowReactive(props):instance.type.props?instance.props=props:instance.props=attrs,instance.attrs=attrs}function updateProps(instance,rawProps,rawPrevProps,optimized){const{props,attrs,vnode:{patchFlag}}=instance,rawCurrentProps=toRaw(props),[options]=instance.propsOptions;let hasAttrsChanged=!1;if((optimized||patchFlag>0)&&!(patchFlag&16)){if(patchFlag&8){const propsToUpdate=instance.vnode.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){let key=propsToUpdate[i];if(isEmitListener(instance.emitsOptions,key))continue;const value=rawProps[key];if(options)if(hasOwn(attrs,key))value!==attrs[key]&&(attrs[key]=value,hasAttrsChanged=!0);else{const camelizedKey=camelize(key);props[camelizedKey]=resolvePropValue(options,rawCurrentProps,camelizedKey,value,instance,!1)}else value!==attrs[key]&&(attrs[key]=value,hasAttrsChanged=!0)}}}else{setFullProps(instance,rawProps,props,attrs)&&(hasAttrsChanged=!0);let kebabKey;for(const key in rawCurrentProps)(!rawProps||!hasOwn(rawProps,key)&&((kebabKey=hyphenate(key))===key||!hasOwn(rawProps,kebabKey)))&&(options?rawPrevProps&&(rawPrevProps[key]!==void 0||rawPrevProps[kebabKey]!==void 0)&&(props[key]=resolvePropValue(options,rawCurrentProps,key,void 0,instance,!0)):delete props[key]);if(attrs!==rawCurrentProps)for(const key in attrs)(!rawProps||!hasOwn(rawProps,key))&&(delete attrs[key],hasAttrsChanged=!0)}hasAttrsChanged&&trigger(instance,"set","$attrs")}function setFullProps(instance,rawProps,props,attrs){const[options,needCastKeys]=instance.propsOptions;let hasAttrsChanged=!1,rawCastValues;if(rawProps)for(let key in rawProps){if(isReservedProp(key))continue;const value=rawProps[key];let camelKey;options&&hasOwn(options,camelKey=camelize(key))?!needCastKeys||!needCastKeys.includes(camelKey)?props[camelKey]=value:(rawCastValues||(rawCastValues={}))[camelKey]=value:isEmitListener(instance.emitsOptions,key)||(!(key in attrs)||value!==attrs[key])&&(attrs[key]=value,hasAttrsChanged=!0)}if(needCastKeys){const rawCurrentProps=toRaw(props),castValues=rawCastValues||EMPTY_OBJ;for(let i=0;i<needCastKeys.length;i++){const key=needCastKeys[i];props[key]=resolvePropValue(options,rawCurrentProps,key,castValues[key],instance,!hasOwn(castValues,key))}}return hasAttrsChanged}function resolvePropValue(options,props,key,value,instance,isAbsent){const opt=options[key];if(opt!=null){const hasDefault=hasOwn(opt,"default");if(hasDefault&&value===void 0){const defaultValue=opt.default;if(opt.type!==Function&&!opt.skipFactory&&isFunction(defaultValue)){const{propsDefaults}=instance;key in propsDefaults?value=propsDefaults[key]:(setCurrentInstance(instance),value=propsDefaults[key]=defaultValue.call(null,props),unsetCurrentInstance())}else value=defaultValue}opt[0]&&(isAbsent&&!hasDefault?value=!1:opt[1]&&(value===""||value===hyphenate(key))&&(value=!0))}return value}function normalizePropsOptions(comp,appContext,asMixin=!1){const cache=appContext.propsCache,cached=cache.get(comp);if(cached)return cached;const raw=comp.props,normalized={},needCastKeys=[];let hasExtends=!1;if(!isFunction(comp)){const extendProps=raw2=>{hasExtends=!0;const[props,keys]=normalizePropsOptions(raw2,appContext,!0);extend(normalized,props),keys&&needCastKeys.push(...keys)};!asMixin&&appContext.mixins.length&&appContext.mixins.forEach(extendProps),comp.extends&&extendProps(comp.extends),comp.mixins&&comp.mixins.forEach(extendProps)}if(!raw&&!hasExtends)return isObject(comp)&&cache.set(comp,EMPTY_ARR),EMPTY_ARR;if(isArray(raw))for(let i=0;i<raw.length;i++){const normalizedKey=camelize(raw[i]);validatePropName(normalizedKey)&&(normalized[normalizedKey]=EMPTY_OBJ)}else if(raw)for(const key in raw){const normalizedKey=camelize(key);if(validatePropName(normalizedKey)){const opt=raw[key],prop=normalized[normalizedKey]=isArray(opt)||isFunction(opt)?{type:opt}:extend({},opt);if(prop){const booleanIndex=getTypeIndex(Boolean,prop.type),stringIndex=getTypeIndex(String,prop.type);prop[0]=booleanIndex>-1,prop[1]=stringIndex<0||booleanIndex<stringIndex,(booleanIndex>-1||hasOwn(prop,"default"))&&needCastKeys.push(normalizedKey)}}}const res=[normalized,needCastKeys];return isObject(comp)&&cache.set(comp,res),res}function validatePropName(key){return key[0]!=="$"}function getType(ctor){const match=ctor&&ctor.toString().match(/^\s*(function|class) (\w+)/);return match?match[2]:ctor===null?"null":""}function isSameType(a,b){return getType(a)===getType(b)}function getTypeIndex(type,expectedTypes){return isArray(expectedTypes)?expectedTypes.findIndex(t=>isSameType(t,type)):isFunction(expectedTypes)&&isSameType(expectedTypes,type)?0:-1}const isInternalKey=key=>key[0]==="_"||key==="$stable",normalizeSlotValue=value=>isArray(value)?value.map(normalizeVNode):[normalizeVNode(value)],normalizeSlot=(key,rawSlot,ctx)=>{if(rawSlot._n)return rawSlot;const normalized=withCtx((...args)=>normalizeSlotValue(rawSlot(...args)),ctx);return normalized._c=!1,normalized},normalizeObjectSlots=(rawSlots,slots,instance)=>{const ctx=rawSlots._ctx;for(const key in rawSlots){if(isInternalKey(key))continue;const value=rawSlots[key];if(isFunction(value))slots[key]=normalizeSlot(key,value,ctx);else if(value!=null){const normalized=normalizeSlotValue(value);slots[key]=()=>normalized}}},normalizeVNodeSlots=(instance,children)=>{const normalized=normalizeSlotValue(children);instance.slots.default=()=>normalized},initSlots=(instance,children)=>{if(instance.vnode.shapeFlag&32){const type=children._;type?(instance.slots=toRaw(children),def(children,"_",type)):normalizeObjectSlots(children,instance.slots={})}else instance.slots={},children&&normalizeVNodeSlots(instance,children);def(instance.slots,InternalObjectKey,1)},updateSlots=(instance,children,optimized)=>{const{vnode,slots}=instance;let needDeletionCheck=!0,deletionComparisonTarget=EMPTY_OBJ;if(vnode.shapeFlag&32){const type=children._;type?optimized&&type===1?needDeletionCheck=!1:(extend(slots,children),!optimized&&type===1&&delete slots._):(needDeletionCheck=!children.$stable,normalizeObjectSlots(children,slots)),deletionComparisonTarget=children}else children&&(normalizeVNodeSlots(instance,children),deletionComparisonTarget={default:1});if(needDeletionCheck)for(const key in slots)!isInternalKey(key)&&deletionComparisonTarget[key]==null&&delete slots[key]};function setRef(rawRef,oldRawRef,parentSuspense,vnode,isUnmount=!1){if(isArray(rawRef)){rawRef.forEach((r,i)=>setRef(r,oldRawRef&&(isArray(oldRawRef)?oldRawRef[i]:oldRawRef),parentSuspense,vnode,isUnmount));return}if(isAsyncWrapper(vnode)&&!isUnmount)return;const refValue=vnode.shapeFlag&4?getExposeProxy(vnode.component)||vnode.component.proxy:vnode.el,value=isUnmount?null:refValue,{i:owner,r:ref3}=rawRef,oldRef=oldRawRef&&oldRawRef.r,refs=owner.refs===EMPTY_OBJ?owner.refs={}:owner.refs,setupState=owner.setupState;if(oldRef!=null&&oldRef!==ref3&&(isString(oldRef)?(refs[oldRef]=null,hasOwn(setupState,oldRef)&&(setupState[oldRef]=null)):isRef(oldRef)&&(oldRef.value=null)),isFunction(ref3))callWithErrorHandling(ref3,owner,12,[value,refs]);else{const _isString=isString(ref3),_isRef=isRef(ref3);if(_isString||_isRef){const doSet=()=>{if(rawRef.f){const existing=_isString?hasOwn(setupState,ref3)?setupState[ref3]:refs[ref3]:ref3.value;isUnmount?isArray(existing)&&remove(existing,refValue):isArray(existing)?existing.includes(refValue)||existing.push(refValue):_isString?(refs[ref3]=[refValue],hasOwn(setupState,ref3)&&(setupState[ref3]=refs[ref3])):(ref3.value=[refValue],rawRef.k&&(refs[rawRef.k]=ref3.value))}else _isString?(refs[ref3]=value,hasOwn(setupState,ref3)&&(setupState[ref3]=value)):_isRef&&(ref3.value=value,rawRef.k&&(refs[rawRef.k]=value))};value?(doSet.id=-1,queuePostRenderEffect(doSet,parentSuspense)):doSet()}}}let hasMismatch=!1;const isSVGContainer=container=>/svg/.test(container.namespaceURI)&&container.tagName!=="foreignObject",isComment=node=>node.nodeType===8;function createHydrationFunctions(rendererInternals){const{mt:mountComponent,p:patch,o:{patchProp:patchProp2,createText,nextSibling,parentNode,remove:remove2,insert,createComment}}=rendererInternals,hydrate2=(vnode,container)=>{if(!container.hasChildNodes()){patch(null,vnode,container),flushPostFlushCbs(),container._vnode=vnode;return}hasMismatch=!1,hydrateNode(container.firstChild,vnode,null,null,null),flushPostFlushCbs(),container._vnode=vnode,hasMismatch&&console.error("Hydration completed but contains mismatches.")},hydrateNode=(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized=!1)=>{const isFragmentStart=isComment(node)&&node.data==="[",onMismatch=()=>handleMismatch(node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragmentStart),{type,ref:ref3,shapeFlag,patchFlag}=vnode;let domType=node.nodeType;vnode.el=node,patchFlag===-2&&(optimized=!1,vnode.dynamicChildren=null);let nextNode=null;switch(type){case Text:domType!==3?vnode.children===""?(insert(vnode.el=createText(""),parentNode(node),node),nextNode=node):nextNode=onMismatch():(node.data!==vnode.children&&(hasMismatch=!0,node.data=vnode.children),nextNode=nextSibling(node));break;case Comment:isTemplateNode2(node)?(nextNode=nextSibling(node),replaceNode(vnode.el=node.content.firstChild,node,parentComponent)):domType!==8||isFragmentStart?nextNode=onMismatch():nextNode=nextSibling(node);break;case Static:if(isFragmentStart&&(node=nextSibling(node),domType=node.nodeType),domType===1||domType===3){nextNode=node;const needToAdoptContent=!vnode.children.length;for(let i=0;i<vnode.staticCount;i++)needToAdoptContent&&(vnode.children+=nextNode.nodeType===1?nextNode.outerHTML:nextNode.data),i===vnode.staticCount-1&&(vnode.anchor=nextNode),nextNode=nextSibling(nextNode);return isFragmentStart?nextSibling(nextNode):nextNode}else onMismatch();break;case Fragment:isFragmentStart?nextNode=hydrateFragment(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized):nextNode=onMismatch();break;default:if(shapeFlag&1)(domType!==1||vnode.type.toLowerCase()!==node.tagName.toLowerCase())&&!isTemplateNode2(node)?nextNode=onMismatch():nextNode=hydrateElement(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);else if(shapeFlag&6){vnode.slotScopeIds=slotScopeIds;const container=parentNode(node);if(isFragmentStart?nextNode=locateClosingAnchor(node):isComment(node)&&node.data==="teleport start"?nextNode=locateClosingAnchor(node,node.data,"teleport end"):nextNode=nextSibling(node),mountComponent(vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container),optimized),isAsyncWrapper(vnode)){let subTree;isFragmentStart?(subTree=createVNode(Fragment),subTree.anchor=nextNode?nextNode.previousSibling:container.lastChild):subTree=node.nodeType===3?createTextVNode(""):createVNode("div"),subTree.el=node,vnode.component.subTree=subTree}}else shapeFlag&64?domType!==8?nextNode=onMismatch():nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,rendererInternals,hydrateChildren):shapeFlag&128&&(nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,isSVGContainer(parentNode(node)),slotScopeIds,optimized,rendererInternals,hydrateNode))}return ref3!=null&&setRef(ref3,null,parentSuspense,vnode),nextNode},hydrateElement=(el,vnode,parentComponent,parentSuspense,slotScopeIds,optimized)=>{optimized=optimized||!!vnode.dynamicChildren;const{type,props,patchFlag,shapeFlag,dirs,transition}=vnode,forcePatch=type==="input"||type==="option";if(forcePatch||patchFlag!==-1){if(dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created"),props)if(forcePatch||!optimized||patchFlag&48)for(const key in props)(forcePatch&&(key.endsWith("value")||key==="indeterminate")||isOn(key)&&!isReservedProp(key)||key[0]===".")&&patchProp2(el,key,null,props[key],!1,void 0,parentComponent);else props.onClick&&patchProp2(el,"onClick",null,props.onClick,!1,void 0,parentComponent);let vnodeHooks;(vnodeHooks=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHooks,parentComponent,vnode);let needCallTransitionHooks=!1;if(isTemplateNode2(el)){needCallTransitionHooks=needTransition(parentSuspense,transition)&&parentComponent&&parentComponent.vnode.props&&parentComponent.vnode.props.appear;const content=el.content.firstChild;needCallTransitionHooks&&transition.beforeEnter(content),replaceNode(content,el,parentComponent),vnode.el=el=content}if(dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount"),((vnodeHooks=props&&props.onVnodeMounted)||dirs||needCallTransitionHooks)&&queueEffectWithSuspense(()=>{vnodeHooks&&invokeVNodeHook(vnodeHooks,parentComponent,vnode),needCallTransitionHooks&&transition.enter(el),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense),shapeFlag&16&&!(props&&(props.innerHTML||props.textContent))){let next=hydrateChildren(el.firstChild,vnode,el,parentComponent,parentSuspense,slotScopeIds,optimized);for(;next;){hasMismatch=!0;const cur=next;next=next.nextSibling,remove2(cur)}}else shapeFlag&8&&el.textContent!==vnode.children&&(hasMismatch=!0,el.textContent=vnode.children)}return el.nextSibling},hydrateChildren=(node,parentVNode,container,parentComponent,parentSuspense,slotScopeIds,optimized)=>{optimized=optimized||!!parentVNode.dynamicChildren;const children=parentVNode.children,l=children.length;for(let i=0;i<l;i++){const vnode=optimized?children[i]:children[i]=normalizeVNode(children[i]);if(node)node=hydrateNode(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);else{if(vnode.type===Text&&!vnode.children)continue;hasMismatch=!0,patch(null,vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container),slotScopeIds)}}return node},hydrateFragment=(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized)=>{const{slotScopeIds:fragmentSlotScopeIds}=vnode;fragmentSlotScopeIds&&(slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds);const container=parentNode(node),next=hydrateChildren(nextSibling(node),vnode,container,parentComponent,parentSuspense,slotScopeIds,optimized);return next&&isComment(next)&&next.data==="]"?nextSibling(vnode.anchor=next):(hasMismatch=!0,insert(vnode.anchor=createComment("]"),container,next),next)},handleMismatch=(node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragment)=>{if(hasMismatch=!0,vnode.el=null,isFragment){const end=locateClosingAnchor(node);for(;;){const next2=nextSibling(node);if(next2&&next2!==end)remove2(next2);else break}}const next=nextSibling(node),container=parentNode(node);return remove2(node),patch(null,vnode,container,next,parentComponent,parentSuspense,isSVGContainer(container),slotScopeIds),next},locateClosingAnchor=(node,open="[",close="]")=>{let match=0;for(;node;)if(node=nextSibling(node),node&&isComment(node)&&(node.data===open&&match++,node.data===close)){if(match===0)return nextSibling(node);match--}return node},replaceNode=(newNode,oldNode,parentComponent)=>{const parentNode2=oldNode.parentNode;parentNode2&&parentNode2.replaceChild(newNode,oldNode);let parent=parentComponent;for(;parent;)parent.vnode.el===oldNode&&(parent.vnode.el=parent.subTree.el=newNode),parent=parent.parent},isTemplateNode2=node=>node.nodeType===1&&node.tagName.toLowerCase()==="template";return[hydrate2,hydrateNode]}const queuePostRenderEffect=queueEffectWithSuspense;function createRenderer(options){return baseCreateRenderer(options)}function createHydrationRenderer(options){return baseCreateRenderer(options,createHydrationFunctions)}function baseCreateRenderer(options,createHydrationFns){const target=getGlobalThis();target.__VUE__=!0;const{insert:hostInsert,remove:hostRemove,patchProp:hostPatchProp,createElement:hostCreateElement,createText:hostCreateText,createComment:hostCreateComment,setText:hostSetText,setElementText:hostSetElementText,parentNode:hostParentNode,nextSibling:hostNextSibling,setScopeId:hostSetScopeId=NOOP,insertStaticContent:hostInsertStaticContent}=options,patch=(n1,n2,container,anchor=null,parentComponent=null,parentSuspense=null,isSVG=!1,slotScopeIds=null,optimized=!!n2.dynamicChildren)=>{if(n1===n2)return;n1&&!isSameVNodeType(n1,n2)&&(anchor=getNextHostNode(n1),unmount(n1,parentComponent,parentSuspense,!0),n1=null),n2.patchFlag===-2&&(optimized=!1,n2.dynamicChildren=null);const{type,ref:ref3,shapeFlag}=n2;switch(type){case Text:processText(n1,n2,container,anchor);break;case Comment:processCommentNode(n1,n2,container,anchor);break;case Static:n1==null&&mountStaticNode(n2,container,anchor,isSVG);break;case Fragment:processFragment(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);break;default:shapeFlag&1?processElement(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):shapeFlag&6?processComponent(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):(shapeFlag&64||shapeFlag&128)&&type.process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals)}ref3!=null&&parentComponent&&setRef(ref3,n1&&n1.ref,parentSuspense,n2||n1,!n2)},processText=(n1,n2,container,anchor)=>{if(n1==null)hostInsert(n2.el=hostCreateText(n2.children),container,anchor);else{const el=n2.el=n1.el;n2.children!==n1.children&&hostSetText(el,n2.children)}},processCommentNode=(n1,n2,container,anchor)=>{n1==null?hostInsert(n2.el=hostCreateComment(n2.children||""),container,anchor):n2.el=n1.el},mountStaticNode=(n2,container,anchor,isSVG)=>{[n2.el,n2.anchor]=hostInsertStaticContent(n2.children,container,anchor,isSVG,n2.el,n2.anchor)},moveStaticNode=({el,anchor},container,nextSibling)=>{let next;for(;el&&el!==anchor;)next=hostNextSibling(el),hostInsert(el,container,nextSibling),el=next;hostInsert(anchor,container,nextSibling)},removeStaticNode=({el,anchor})=>{let next;for(;el&&el!==anchor;)next=hostNextSibling(el),hostRemove(el),el=next;hostRemove(anchor)},processElement=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{isSVG=isSVG||n2.type==="svg",n1==null?mountElement(n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):patchElement(n1,n2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)},mountElement=(vnode,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{let el,vnodeHook;const{type,props,shapeFlag,transition,dirs}=vnode;if(el=vnode.el=hostCreateElement(vnode.type,isSVG,props&&props.is,props),shapeFlag&8?hostSetElementText(el,vnode.children):shapeFlag&16&&mountChildren(vnode.children,el,null,parentComponent,parentSuspense,isSVG&&type!=="foreignObject",slotScopeIds,optimized),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"created"),setScopeId(el,vnode,vnode.scopeId,slotScopeIds,parentComponent),props){for(const key in props)key!=="value"&&!isReservedProp(key)&&hostPatchProp(el,key,null,props[key],isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);"value"in props&&hostPatchProp(el,"value",null,props.value),(vnodeHook=props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode)}dirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeMount");const needCallTransitionHooks=needTransition(parentSuspense,transition);needCallTransitionHooks&&transition.beforeEnter(el),hostInsert(el,container,anchor),((vnodeHook=props&&props.onVnodeMounted)||needCallTransitionHooks||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),needCallTransitionHooks&&transition.enter(el),dirs&&invokeDirectiveHook(vnode,null,parentComponent,"mounted")},parentSuspense)},setScopeId=(el,vnode,scopeId,slotScopeIds,parentComponent)=>{if(scopeId&&hostSetScopeId(el,scopeId),slotScopeIds)for(let i=0;i<slotScopeIds.length;i++)hostSetScopeId(el,slotScopeIds[i]);if(parentComponent){let subTree=parentComponent.subTree;if(vnode===subTree){const parentVNode=parentComponent.vnode;setScopeId(el,parentVNode,parentVNode.scopeId,parentVNode.slotScopeIds,parentComponent.parent)}}},mountChildren=(children,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,start=0)=>{for(let i=start;i<children.length;i++){const child=children[i]=optimized?cloneIfMounted(children[i]):normalizeVNode(children[i]);patch(null,child,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)}},patchElement=(n1,n2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{const el=n2.el=n1.el;let{patchFlag,dynamicChildren,dirs}=n2;patchFlag|=n1.patchFlag&16;const oldProps=n1.props||EMPTY_OBJ,newProps=n2.props||EMPTY_OBJ;let vnodeHook;parentComponent&&toggleRecurse(parentComponent,!1),(vnodeHook=newProps.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"beforeUpdate"),parentComponent&&toggleRecurse(parentComponent,!0);const areChildrenSVG=isSVG&&n2.type!=="foreignObject";if(dynamicChildren?patchBlockChildren(n1.dynamicChildren,dynamicChildren,el,parentComponent,parentSuspense,areChildrenSVG,slotScopeIds):optimized||patchChildren(n1,n2,el,null,parentComponent,parentSuspense,areChildrenSVG,slotScopeIds,!1),patchFlag>0){if(patchFlag&16)patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);else if(patchFlag&2&&oldProps.class!==newProps.class&&hostPatchProp(el,"class",null,newProps.class,isSVG),patchFlag&4&&hostPatchProp(el,"style",oldProps.style,newProps.style,isSVG),patchFlag&8){const propsToUpdate=n2.dynamicProps;for(let i=0;i<propsToUpdate.length;i++){const key=propsToUpdate[i],prev=oldProps[key],next=newProps[key];(next!==prev||key==="value")&&hostPatchProp(el,key,prev,next,isSVG,n1.children,parentComponent,parentSuspense,unmountChildren)}}patchFlag&1&&n1.children!==n2.children&&hostSetElementText(el,n2.children)}else!optimized&&dynamicChildren==null&&patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);((vnodeHook=newProps.onVnodeUpdated)||dirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1),dirs&&invokeDirectiveHook(n2,n1,parentComponent,"updated")},parentSuspense)},patchBlockChildren=(oldChildren,newChildren,fallbackContainer,parentComponent,parentSuspense,isSVG,slotScopeIds)=>{for(let i=0;i<newChildren.length;i++){const oldVNode=oldChildren[i],newVNode=newChildren[i],container=oldVNode.el&&(oldVNode.type===Fragment||!isSameVNodeType(oldVNode,newVNode)||oldVNode.shapeFlag&70)?hostParentNode(oldVNode.el):fallbackContainer;patch(oldVNode,newVNode,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,!0)}},patchProps=(el,vnode,oldProps,newProps,parentComponent,parentSuspense,isSVG)=>{if(oldProps!==newProps){if(oldProps!==EMPTY_OBJ)for(const key in oldProps)!isReservedProp(key)&&!(key in newProps)&&hostPatchProp(el,key,oldProps[key],null,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);for(const key in newProps){if(isReservedProp(key))continue;const next=newProps[key],prev=oldProps[key];next!==prev&&key!=="value"&&hostPatchProp(el,key,prev,next,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren)}"value"in newProps&&hostPatchProp(el,"value",oldProps.value,newProps.value)}},processFragment=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{const fragmentStartAnchor=n2.el=n1?n1.el:hostCreateText(""),fragmentEndAnchor=n2.anchor=n1?n1.anchor:hostCreateText("");let{patchFlag,dynamicChildren,slotScopeIds:fragmentSlotScopeIds}=n2;fragmentSlotScopeIds&&(slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds),n1==null?(hostInsert(fragmentStartAnchor,container,anchor),hostInsert(fragmentEndAnchor,container,anchor),mountChildren(n2.children,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)):patchFlag>0&&patchFlag&64&&dynamicChildren&&n1.dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,container,parentComponent,parentSuspense,isSVG,slotScopeIds),(n2.key!=null||parentComponent&&n2===parentComponent.subTree)&&traverseStaticChildren(n1,n2,!0)):patchChildren(n1,n2,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)},processComponent=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{n2.slotScopeIds=slotScopeIds,n1==null?n2.shapeFlag&512?parentComponent.ctx.activate(n2,container,anchor,isSVG,optimized):mountComponent(n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized):updateComponent(n1,n2,optimized)},mountComponent=(initialVNode,container,anchor,parentComponent,parentSuspense,isSVG,optimized)=>{const instance=initialVNode.component=createComponentInstance(initialVNode,parentComponent,parentSuspense);if(isKeepAlive(initialVNode)&&(instance.ctx.renderer=internals),setupComponent(instance),instance.asyncDep){if(parentSuspense&&parentSuspense.registerDep(instance,setupRenderEffect),!initialVNode.el){const placeholder=instance.subTree=createVNode(Comment);processCommentNode(null,placeholder,container,anchor)}return}setupRenderEffect(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized)},updateComponent=(n1,n2,optimized)=>{const instance=n2.component=n1.component;if(shouldUpdateComponent(n1,n2,optimized))if(instance.asyncDep&&!instance.asyncResolved){updateComponentPreRender(instance,n2,optimized);return}else instance.next=n2,invalidateJob(instance.update),instance.update();else n2.el=n1.el,instance.vnode=n2},setupRenderEffect=(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized)=>{const componentUpdateFn=()=>{if(instance.isMounted){let{next,bu,u,parent,vnode}=instance,originNext=next,vnodeHook;toggleRecurse(instance,!1),next?(next.el=vnode.el,updateComponentPreRender(instance,next,optimized)):next=vnode,bu&&invokeArrayFns(bu),(vnodeHook=next.props&&next.props.onVnodeBeforeUpdate)&&invokeVNodeHook(vnodeHook,parent,next,vnode),toggleRecurse(instance,!0);const nextTree=renderComponentRoot(instance),prevTree=instance.subTree;instance.subTree=nextTree,patch(prevTree,nextTree,hostParentNode(prevTree.el),getNextHostNode(prevTree),instance,parentSuspense,isSVG),next.el=nextTree.el,originNext===null&&updateHOCHostEl(instance,nextTree.el),u&&queuePostRenderEffect(u,parentSuspense),(vnodeHook=next.props&&next.props.onVnodeUpdated)&&queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook,parent,next,vnode),parentSuspense)}else{let vnodeHook;const{el,props}=initialVNode,{bm,m,parent}=instance,isAsyncWrapperVNode=isAsyncWrapper(initialVNode);if(toggleRecurse(instance,!1),bm&&invokeArrayFns(bm),!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeBeforeMount)&&invokeVNodeHook(vnodeHook,parent,initialVNode),toggleRecurse(instance,!0),el&&hydrateNode){const hydrateSubTree=()=>{instance.subTree=renderComponentRoot(instance),hydrateNode(el,instance.subTree,instance,parentSuspense,null)};isAsyncWrapperVNode?initialVNode.type.__asyncLoader().then(()=>!instance.isUnmounted&&hydrateSubTree()):hydrateSubTree()}else{const subTree=instance.subTree=renderComponentRoot(instance);patch(null,subTree,container,anchor,instance,parentSuspense,isSVG),initialVNode.el=subTree.el}if(m&&queuePostRenderEffect(m,parentSuspense),!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeMounted)){const scopedInitialVNode=initialVNode;queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook,parent,scopedInitialVNode),parentSuspense)}(initialVNode.shapeFlag&256||parent&&isAsyncWrapper(parent.vnode)&&parent.vnode.shapeFlag&256)&&instance.a&&queuePostRenderEffect(instance.a,parentSuspense),instance.isMounted=!0,initialVNode=container=anchor=null}},effect2=instance.effect=new ReactiveEffect(componentUpdateFn,()=>queueJob(update),instance.scope),update=instance.update=()=>effect2.run();update.id=instance.uid,toggleRecurse(instance,!0),update()},updateComponentPreRender=(instance,nextVNode,optimized)=>{nextVNode.component=instance;const prevProps=instance.vnode.props;instance.vnode=nextVNode,instance.next=null,updateProps(instance,nextVNode.props,prevProps,optimized),updateSlots(instance,nextVNode.children,optimized),pauseTracking(),flushPreFlushCbs(),resetTracking()},patchChildren=(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized=!1)=>{const c1=n1&&n1.children,prevShapeFlag=n1?n1.shapeFlag:0,c2=n2.children,{patchFlag,shapeFlag}=n2;if(patchFlag>0){if(patchFlag&128){patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);return}else if(patchFlag&256){patchUnkeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);return}}shapeFlag&8?(prevShapeFlag&16&&unmountChildren(c1,parentComponent,parentSuspense),c2!==c1&&hostSetElementText(container,c2)):prevShapeFlag&16?shapeFlag&16?patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):unmountChildren(c1,parentComponent,parentSuspense,!0):(prevShapeFlag&8&&hostSetElementText(container,""),shapeFlag&16&&mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized))},patchUnkeyedChildren=(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{c1=c1||EMPTY_ARR,c2=c2||EMPTY_ARR;const oldLength=c1.length,newLength=c2.length,commonLength=Math.min(oldLength,newLength);let i;for(i=0;i<commonLength;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);patch(c1[i],nextChild,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)}oldLength>newLength?unmountChildren(c1,parentComponent,parentSuspense,!0,!1,commonLength):mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,commonLength)},patchKeyedChildren=(c1,c2,container,parentAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)=>{let i=0;const l2=c2.length;let e1=c1.length-1,e2=l2-1;for(;i<=e1&&i<=e2;){const n1=c1[i],n2=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);if(isSameVNodeType(n1,n2))patch(n1,n2,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);else break;i++}for(;i<=e1&&i<=e2;){const n1=c1[e1],n2=c2[e2]=optimized?cloneIfMounted(c2[e2]):normalizeVNode(c2[e2]);if(isSameVNodeType(n1,n2))patch(n1,n2,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);else break;e1--,e2--}if(i>e1){if(i<=e2){const nextPos=e2+1,anchor=nextPos<l2?c2[nextPos].el:parentAnchor;for(;i<=e2;)patch(null,c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]),container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized),i++}}else if(i>e2)for(;i<=e1;)unmount(c1[i],parentComponent,parentSuspense,!0),i++;else{const s1=i,s2=i,keyToNewIndexMap=new Map;for(i=s2;i<=e2;i++){const nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);nextChild.key!=null&&keyToNewIndexMap.set(nextChild.key,i)}let j,patched=0;const toBePatched=e2-s2+1;let moved=!1,maxNewIndexSoFar=0;const newIndexToOldIndexMap=new Array(toBePatched);for(i=0;i<toBePatched;i++)newIndexToOldIndexMap[i]=0;for(i=s1;i<=e1;i++){const prevChild=c1[i];if(patched>=toBePatched){unmount(prevChild,parentComponent,parentSuspense,!0);continue}let newIndex;if(prevChild.key!=null)newIndex=keyToNewIndexMap.get(prevChild.key);else for(j=s2;j<=e2;j++)if(newIndexToOldIndexMap[j-s2]===0&&isSameVNodeType(prevChild,c2[j])){newIndex=j;break}newIndex===void 0?unmount(prevChild,parentComponent,parentSuspense,!0):(newIndexToOldIndexMap[newIndex-s2]=i+1,newIndex>=maxNewIndexSoFar?maxNewIndexSoFar=newIndex:moved=!0,patch(prevChild,c2[newIndex],container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized),patched++)}const increasingNewIndexSequence=moved?getSequence(newIndexToOldIndexMap):EMPTY_ARR;for(j=increasingNewIndexSequence.length-1,i=toBePatched-1;i>=0;i--){const nextIndex=s2+i,nextChild=c2[nextIndex],anchor=nextIndex+1<l2?c2[nextIndex+1].el:parentAnchor;newIndexToOldIndexMap[i]===0?patch(null,nextChild,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized):moved&&(j<0||i!==increasingNewIndexSequence[j]?move(nextChild,container,anchor,2):j--)}}},move=(vnode,container,anchor,moveType,parentSuspense=null)=>{const{el,type,transition,children,shapeFlag}=vnode;if(shapeFlag&6){move(vnode.component.subTree,container,anchor,moveType);return}if(shapeFlag&128){vnode.suspense.move(container,anchor,moveType);return}if(shapeFlag&64){type.move(vnode,container,anchor,internals);return}if(type===Fragment){hostInsert(el,container,anchor);for(let i=0;i<children.length;i++)move(children[i],container,anchor,moveType);hostInsert(vnode.anchor,container,anchor);return}if(type===Static){moveStaticNode(vnode,container,anchor);return}if(moveType!==2&&shapeFlag&1&&transition)if(moveType===0)transition.beforeEnter(el),hostInsert(el,container,anchor),queuePostRenderEffect(()=>transition.enter(el),parentSuspense);else{const{leave,delayLeave,afterLeave}=transition,remove22=()=>hostInsert(el,container,anchor),performLeave=()=>{leave(el,()=>{remove22(),afterLeave&&afterLeave()})};delayLeave?delayLeave(el,remove22,performLeave):performLeave()}else hostInsert(el,container,anchor)},unmount=(vnode,parentComponent,parentSuspense,doRemove=!1,optimized=!1)=>{const{type,props,ref:ref3,children,dynamicChildren,shapeFlag,patchFlag,dirs}=vnode;if(ref3!=null&&setRef(ref3,null,parentSuspense,vnode,!0),shapeFlag&256){parentComponent.ctx.deactivate(vnode);return}const shouldInvokeDirs=shapeFlag&1&&dirs,shouldInvokeVnodeHook=!isAsyncWrapper(vnode);let vnodeHook;if(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeBeforeUnmount)&&invokeVNodeHook(vnodeHook,parentComponent,vnode),shapeFlag&6)unmountComponent(vnode.component,parentSuspense,doRemove);else{if(shapeFlag&128){vnode.suspense.unmount(parentSuspense,doRemove);return}shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"beforeUnmount"),shapeFlag&64?vnode.type.remove(vnode,parentComponent,parentSuspense,optimized,internals,doRemove):dynamicChildren&&(type!==Fragment||patchFlag>0&&patchFlag&64)?unmountChildren(dynamicChildren,parentComponent,parentSuspense,!1,!0):(type===Fragment&&patchFlag&384||!optimized&&shapeFlag&16)&&unmountChildren(children,parentComponent,parentSuspense),doRemove&&remove2(vnode)}(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeUnmounted)||shouldInvokeDirs)&&queuePostRenderEffect(()=>{vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode),shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,"unmounted")},parentSuspense)},remove2=vnode=>{const{type,el,anchor,transition}=vnode;if(type===Fragment){removeFragment(el,anchor);return}if(type===Static){removeStaticNode(vnode);return}const performRemove=()=>{hostRemove(el),transition&&!transition.persisted&&transition.afterLeave&&transition.afterLeave()};if(vnode.shapeFlag&1&&transition&&!transition.persisted){const{leave,delayLeave}=transition,performLeave=()=>leave(el,performRemove);delayLeave?delayLeave(vnode.el,performRemove,performLeave):performLeave()}else performRemove()},removeFragment=(cur,end)=>{let next;for(;cur!==end;)next=hostNextSibling(cur),hostRemove(cur),cur=next;hostRemove(end)},unmountComponent=(instance,parentSuspense,doRemove)=>{const{bum,scope,update,subTree,um}=instance;bum&&invokeArrayFns(bum),scope.stop(),update&&(update.active=!1,unmount(subTree,instance,parentSuspense,doRemove)),um&&queuePostRenderEffect(um,parentSuspense),queuePostRenderEffect(()=>{instance.isUnmounted=!0},parentSuspense),parentSuspense&&parentSuspense.pendingBranch&&!parentSuspense.isUnmounted&&instance.asyncDep&&!instance.asyncResolved&&instance.suspenseId===parentSuspense.pendingId&&(parentSuspense.deps--,parentSuspense.deps===0&&parentSuspense.resolve())},unmountChildren=(children,parentComponent,parentSuspense,doRemove=!1,optimized=!1,start=0)=>{for(let i=start;i<children.length;i++)unmount(children[i],parentComponent,parentSuspense,doRemove,optimized)},getNextHostNode=vnode=>vnode.shapeFlag&6?getNextHostNode(vnode.component.subTree):vnode.shapeFlag&128?vnode.suspense.next():hostNextSibling(vnode.anchor||vnode.el),render2=(vnode,container,isSVG)=>{vnode==null?container._vnode&&unmount(container._vnode,null,null,!0):patch(container._vnode||null,vnode,container,null,null,null,isSVG),flushPreFlushCbs(),flushPostFlushCbs(),container._vnode=vnode},internals={p:patch,um:unmount,m:move,r:remove2,mt:mountComponent,mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,n:getNextHostNode,o:options};let hydrate2,hydrateNode;return createHydrationFns&&([hydrate2,hydrateNode]=createHydrationFns(internals)),{render:render2,hydrate:hydrate2,createApp:createAppAPI(render2,hydrate2)}}function toggleRecurse({effect:effect2,update},allowed){effect2.allowRecurse=update.allowRecurse=allowed}function needTransition(parentSuspense,transition){return(!parentSuspense||parentSuspense&&!parentSuspense.pendingBranch)&&transition&&!transition.persisted}function traverseStaticChildren(n1,n2,shallow=!1){const ch1=n1.children,ch2=n2.children;if(isArray(ch1)&&isArray(ch2))for(let i=0;i<ch1.length;i++){const c1=ch1[i];let c2=ch2[i];c2.shapeFlag&1&&!c2.dynamicChildren&&((c2.patchFlag<=0||c2.patchFlag===32)&&(c2=ch2[i]=cloneIfMounted(ch2[i]),c2.el=c1.el),shallow||traverseStaticChildren(c1,c2)),c2.type===Text&&(c2.el=c1.el)}}function getSequence(arr){const p2=arr.slice(),result=[0];let i,j,u,v,c;const len=arr.length;for(i=0;i<len;i++){const arrI=arr[i];if(arrI!==0){if(j=result[result.length-1],arr[j]<arrI){p2[i]=j,result.push(i);continue}for(u=0,v=result.length-1;u<v;)c=u+v>>1,arr[result[c]]<arrI?u=c+1:v=c;arrI<arr[result[u]]&&(u>0&&(p2[i]=result[u-1]),result[u]=i)}}for(u=result.length,v=result[u-1];u-- >0;)result[u]=v,v=p2[v];return result}const isTeleport=type=>type.__isTeleport,isTeleportDisabled=props=>props&&(props.disabled||props.disabled===""),isTargetSVG=target=>typeof SVGElement<"u"&&target instanceof SVGElement,resolveTarget=(props,select)=>{const targetSelector=props&&props.to;return isString(targetSelector)?select?select(targetSelector):null:targetSelector},TeleportImpl={name:"Teleport",__isTeleport:!0,process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals){const{mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,o:{insert,querySelector,createText,createComment}}=internals,disabled=isTeleportDisabled(n2.props);let{shapeFlag,children,dynamicChildren}=n2;if(n1==null){const placeholder=n2.el=createText(""),mainAnchor=n2.anchor=createText("");insert(placeholder,container,anchor),insert(mainAnchor,container,anchor);const target=n2.target=resolveTarget(n2.props,querySelector),targetAnchor=n2.targetAnchor=createText("");target&&(insert(targetAnchor,target),isSVG=isSVG||isTargetSVG(target));const mount=(container2,anchor2)=>{shapeFlag&16&&mountChildren(children,container2,anchor2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized)};disabled?mount(container,mainAnchor):target&&mount(target,targetAnchor)}else{n2.el=n1.el;const mainAnchor=n2.anchor=n1.anchor,target=n2.target=n1.target,targetAnchor=n2.targetAnchor=n1.targetAnchor,wasDisabled=isTeleportDisabled(n1.props),currentContainer=wasDisabled?container:target,currentAnchor=wasDisabled?mainAnchor:targetAnchor;if(isSVG=isSVG||isTargetSVG(target),dynamicChildren?(patchBlockChildren(n1.dynamicChildren,dynamicChildren,currentContainer,parentComponent,parentSuspense,isSVG,slotScopeIds),traverseStaticChildren(n1,n2,!0)):optimized||patchChildren(n1,n2,currentContainer,currentAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,!1),disabled)wasDisabled?n2.props&&n1.props&&n2.props.to!==n1.props.to&&(n2.props.to=n1.props.to):moveTeleport(n2,container,mainAnchor,internals,1);else if((n2.props&&n2.props.to)!==(n1.props&&n1.props.to)){const nextTarget=n2.target=resolveTarget(n2.props,querySelector);nextTarget&&moveTeleport(n2,nextTarget,null,internals,0)}else wasDisabled&&moveTeleport(n2,target,targetAnchor,internals,1)}updateCssVars(n2)},remove(vnode,parentComponent,parentSuspense,optimized,{um:unmount,o:{remove:hostRemove}},doRemove){const{shapeFlag,children,anchor,targetAnchor,target,props}=vnode;if(target&&hostRemove(targetAnchor),doRemove&&hostRemove(anchor),shapeFlag&16){const shouldRemove=doRemove||!isTeleportDisabled(props);for(let i=0;i<children.length;i++){const child=children[i];unmount(child,parentComponent,parentSuspense,shouldRemove,!!child.dynamicChildren)}}},move:moveTeleport,hydrate:hydrateTeleport};function moveTeleport(vnode,container,parentAnchor,{o:{insert},m:move},moveType=2){moveType===0&&insert(vnode.targetAnchor,container,parentAnchor);const{el,anchor,shapeFlag,children,props}=vnode,isReorder=moveType===2;if(isReorder&&insert(el,container,parentAnchor),(!isReorder||isTeleportDisabled(props))&&shapeFlag&16)for(let i=0;i<children.length;i++)move(children[i],container,parentAnchor,2);isReorder&&insert(anchor,container,parentAnchor)}function hydrateTeleport(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,{o:{nextSibling,parentNode,querySelector}},hydrateChildren){const target=vnode.target=resolveTarget(vnode.props,querySelector);if(target){const targetNode=target._lpa||target.firstChild;if(vnode.shapeFlag&16)if(isTeleportDisabled(vnode.props))vnode.anchor=hydrateChildren(nextSibling(node),vnode,parentNode(node),parentComponent,parentSuspense,slotScopeIds,optimized),vnode.targetAnchor=targetNode;else{vnode.anchor=nextSibling(node);let targetAnchor=targetNode;for(;targetAnchor;)if(targetAnchor=nextSibling(targetAnchor),targetAnchor&&targetAnchor.nodeType===8&&targetAnchor.data==="teleport anchor"){vnode.targetAnchor=targetAnchor,target._lpa=vnode.targetAnchor&&nextSibling(vnode.targetAnchor);break}hydrateChildren(targetNode,vnode,target,parentComponent,parentSuspense,slotScopeIds,optimized)}updateCssVars(vnode)}return vnode.anchor&&nextSibling(vnode.anchor)}const Teleport=TeleportImpl;function updateCssVars(vnode){const ctx=vnode.ctx;if(ctx&&ctx.ut){let node=vnode.children[0].el;for(;node&&node!==vnode.targetAnchor;)node.nodeType===1&&node.setAttribute("data-v-owner",ctx.uid),node=node.nextSibling;ctx.ut()}}const Fragment=Symbol.for("v-fgt"),Text=Symbol.for("v-txt"),Comment=Symbol.for("v-cmt"),Static=Symbol.for("v-stc"),blockStack=[];let currentBlock=null;function openBlock(disableTracking=!1){blockStack.push(currentBlock=disableTracking?null:[])}function closeBlock(){blockStack.pop(),currentBlock=blockStack[blockStack.length-1]||null}let isBlockTreeEnabled=1;function setBlockTracking(value){isBlockTreeEnabled+=value}function setupBlock(vnode){return vnode.dynamicChildren=isBlockTreeEnabled>0?currentBlock||EMPTY_ARR:null,closeBlock(),isBlockTreeEnabled>0&&currentBlock&&currentBlock.push(vnode),vnode}function createElementBlock(type,props,children,patchFlag,dynamicProps,shapeFlag){return setupBlock(createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,!0))}function createBlock(type,props,children,patchFlag,dynamicProps){return setupBlock(createVNode(type,props,children,patchFlag,dynamicProps,!0))}function isVNode(value){return value?value.__v_isVNode===!0:!1}function isSameVNodeType(n1,n2){return n1.type===n2.type&&n1.key===n2.key}function transformVNodeArgs(transformer){}const InternalObjectKey="__vInternal",normalizeKey=({key})=>key??null,normalizeRef=({ref:ref3,ref_key,ref_for})=>(typeof ref3=="number"&&(ref3=""+ref3),ref3!=null?isString(ref3)||isRef(ref3)||isFunction(ref3)?{i:currentRenderingInstance,r:ref3,k:ref_key,f:!!ref_for}:ref3:null);function createBaseVNode(type,props=null,children=null,patchFlag=0,dynamicProps=null,shapeFlag=type===Fragment?0:1,isBlockNode=!1,needFullChildrenNormalization=!1){const vnode={__v_isVNode:!0,__v_skip:!0,type,props,key:props&&normalizeKey(props),ref:props&&normalizeRef(props),scopeId:currentScopeId,slotScopeIds:null,children,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag,patchFlag,dynamicProps,dynamicChildren:null,appContext:null,ctx:currentRenderingInstance};return needFullChildrenNormalization?(normalizeChildren(vnode,children),shapeFlag&128&&type.normalize(vnode)):children&&(vnode.shapeFlag|=isString(children)?8:16),isBlockTreeEnabled>0&&!isBlockNode&&currentBlock&&(vnode.patchFlag>0||shapeFlag&6)&&vnode.patchFlag!==32&&currentBlock.push(vnode),vnode}const createVNode=_createVNode;function _createVNode(type,props=null,children=null,patchFlag=0,dynamicProps=null,isBlockNode=!1){if((!type||type===NULL_DYNAMIC_COMPONENT)&&(type=Comment),isVNode(type)){const cloned=cloneVNode(type,props,!0);return children&&normalizeChildren(cloned,children),isBlockTreeEnabled>0&&!isBlockNode&&currentBlock&&(cloned.shapeFlag&6?currentBlock[currentBlock.indexOf(type)]=cloned:currentBlock.push(cloned)),cloned.patchFlag|=-2,cloned}if(isClassComponent(type)&&(type=type.__vccOpts),props){props=guardReactiveProps(props);let{class:klass,style}=props;klass&&!isString(klass)&&(props.class=normalizeClass(klass)),isObject(style)&&(isProxy(style)&&!isArray(style)&&(style=extend({},style)),props.style=normalizeStyle(style))}const shapeFlag=isString(type)?1:isSuspense(type)?128:isTeleport(type)?64:isObject(type)?4:isFunction(type)?2:0;return createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,isBlockNode,!0)}function guardReactiveProps(props){return props?isProxy(props)||InternalObjectKey in props?extend({},props):props:null}function cloneVNode(vnode,extraProps,mergeRef=!1){const{props,ref:ref3,patchFlag,children}=vnode,mergedProps=extraProps?mergeProps(props||{},extraProps):props;return{__v_isVNode:!0,__v_skip:!0,type:vnode.type,props:mergedProps,key:mergedProps&&normalizeKey(mergedProps),ref:extraProps&&extraProps.ref?mergeRef&&ref3?isArray(ref3)?ref3.concat(normalizeRef(extraProps)):[ref3,normalizeRef(extraProps)]:normalizeRef(extraProps):ref3,scopeId:vnode.scopeId,slotScopeIds:vnode.slotScopeIds,children,target:vnode.target,targetAnchor:vnode.targetAnchor,staticCount:vnode.staticCount,shapeFlag:vnode.shapeFlag,patchFlag:extraProps&&vnode.type!==Fragment?patchFlag===-1?16:patchFlag|16:patchFlag,dynamicProps:vnode.dynamicProps,dynamicChildren:vnode.dynamicChildren,appContext:vnode.appContext,dirs:vnode.dirs,transition:vnode.transition,component:vnode.component,suspense:vnode.suspense,ssContent:vnode.ssContent&&cloneVNode(vnode.ssContent),ssFallback:vnode.ssFallback&&cloneVNode(vnode.ssFallback),el:vnode.el,anchor:vnode.anchor,ctx:vnode.ctx,ce:vnode.ce}}function createTextVNode(text=" ",flag=0){return createVNode(Text,null,text,flag)}function createStaticVNode(content,numberOfNodes){const vnode=createVNode(Static,null,content);return vnode.staticCount=numberOfNodes,vnode}function createCommentVNode(text="",asBlock=!1){return asBlock?(openBlock(),createBlock(Comment,null,text)):createVNode(Comment,null,text)}function normalizeVNode(child){return child==null||typeof child=="boolean"?createVNode(Comment):isArray(child)?createVNode(Fragment,null,child.slice()):typeof child=="object"?cloneIfMounted(child):createVNode(Text,null,String(child))}function cloneIfMounted(child){return child.el===null&&child.patchFlag!==-1||child.memo?child:cloneVNode(child)}function normalizeChildren(vnode,children){let type=0;const{shapeFlag}=vnode;if(children==null)children=null;else if(isArray(children))type=16;else if(typeof children=="object")if(shapeFlag&65){const slot=children.default;slot&&(slot._c&&(slot._d=!1),normalizeChildren(vnode,slot()),slot._c&&(slot._d=!0));return}else{type=32;const slotFlag=children._;!slotFlag&&!(InternalObjectKey in children)?children._ctx=currentRenderingInstance:slotFlag===3&&currentRenderingInstance&&(currentRenderingInstance.slots._===1?children._=1:(children._=2,vnode.patchFlag|=1024))}else isFunction(children)?(children={default:children,_ctx:currentRenderingInstance},type=32):(children=String(children),shapeFlag&64?(type=16,children=[createTextVNode(children)]):type=8);vnode.children=children,vnode.shapeFlag|=type}function mergeProps(...args){const ret={};for(let i=0;i<args.length;i++){const toMerge=args[i];for(const key in toMerge)if(key==="class")ret.class!==toMerge.class&&(ret.class=normalizeClass([ret.class,toMerge.class]));else if(key==="style")ret.style=normalizeStyle([ret.style,toMerge.style]);else if(isOn(key)){const existing=ret[key],incoming=toMerge[key];incoming&&existing!==incoming&&!(isArray(existing)&&existing.includes(incoming))&&(ret[key]=existing?[].concat(existing,incoming):incoming)}else key!==""&&(ret[key]=toMerge[key])}return ret}function invokeVNodeHook(hook,instance,vnode,prevVNode=null){callWithAsyncErrorHandling(hook,instance,7,[vnode,prevVNode])}const emptyAppContext=createAppContext();let uid=0;function createComponentInstance(vnode,parent,suspense){const type=vnode.type,appContext=(parent?parent.appContext:vnode.appContext)||emptyAppContext,instance={uid:uid++,vnode,type,parent,appContext,root:null,next:null,subTree:null,effect:null,update:null,scope:new EffectScope(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:parent?parent.provides:Object.create(appContext.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:normalizePropsOptions(type,appContext),emitsOptions:normalizeEmitsOptions(type,appContext),emit:null,emitted:null,propsDefaults:EMPTY_OBJ,inheritAttrs:type.inheritAttrs,ctx:EMPTY_OBJ,data:EMPTY_OBJ,props:EMPTY_OBJ,attrs:EMPTY_OBJ,slots:EMPTY_OBJ,refs:EMPTY_OBJ,setupState:EMPTY_OBJ,setupContext:null,attrsProxy:null,slotsProxy:null,suspense,suspenseId:suspense?suspense.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return instance.ctx={_:instance},instance.root=parent?parent.root:instance,instance.emit=emit.bind(null,instance),vnode.ce&&vnode.ce(instance),instance}let currentInstance=null;const getCurrentInstance=()=>currentInstance||currentRenderingInstance;let internalSetCurrentInstance,globalCurrentInstanceSetters,settersKey="__VUE_INSTANCE_SETTERS__";(globalCurrentInstanceSetters=getGlobalThis()[settersKey])||(globalCurrentInstanceSetters=getGlobalThis()[settersKey]=[]),globalCurrentInstanceSetters.push(i=>currentInstance=i),internalSetCurrentInstance=instance=>{globalCurrentInstanceSetters.length>1?globalCurrentInstanceSetters.forEach(s=>s(instance)):globalCurrentInstanceSetters[0](instance)};const setCurrentInstance=instance=>{internalSetCurrentInstance(instance),instance.scope.on()},unsetCurrentInstance=()=>{currentInstance&&currentInstance.scope.off(),internalSetCurrentInstance(null)};function isStatefulComponent(instance){return instance.vnode.shapeFlag&4}let isInSSRComponentSetup=!1;function setupComponent(instance,isSSR=!1){isInSSRComponentSetup=isSSR;const{props,children}=instance.vnode,isStateful=isStatefulComponent(instance);initProps(instance,props,isStateful,isSSR),initSlots(instance,children);const setupResult=isStateful?setupStatefulComponent(instance,isSSR):void 0;return isInSSRComponentSetup=!1,setupResult}function setupStatefulComponent(instance,isSSR){const Component=instance.type;instance.accessCache=Object.create(null),instance.proxy=markRaw(new Proxy(instance.ctx,PublicInstanceProxyHandlers));const{setup}=Component;if(setup){const setupContext=instance.setupContext=setup.length>1?createSetupContext(instance):null;setCurrentInstance(instance),pauseTracking();const setupResult=callWithErrorHandling(setup,instance,0,[instance.props,setupContext]);if(resetTracking(),unsetCurrentInstance(),isPromise(setupResult)){if(setupResult.then(unsetCurrentInstance,unsetCurrentInstance),isSSR)return setupResult.then(resolvedResult=>{handleSetupResult(instance,resolvedResult,isSSR)}).catch(e=>{handleError(e,instance,0)});instance.asyncDep=setupResult}else handleSetupResult(instance,setupResult,isSSR)}else finishComponentSetup(instance,isSSR)}function handleSetupResult(instance,setupResult,isSSR){isFunction(setupResult)?instance.type.__ssrInlineRender?instance.ssrRender=setupResult:instance.render=setupResult:isObject(setupResult)&&(instance.setupState=proxyRefs(setupResult)),finishComponentSetup(instance,isSSR)}let compile$1,installWithProxy;function registerRuntimeCompiler(_compile){compile$1=_compile,installWithProxy=i=>{i.render._rc&&(i.withProxy=new Proxy(i.ctx,RuntimeCompiledPublicInstanceProxyHandlers))}}const isRuntimeOnly=()=>!compile$1;function finishComponentSetup(instance,isSSR,skipOptions){const Component=instance.type;if(!instance.render){if(!isSSR&&compile$1&&!Component.render){const template=Component.template||resolveMergedOptions(instance).template;if(template){const{isCustomElement,compilerOptions}=instance.appContext.config,{delimiters,compilerOptions:componentCompilerOptions}=Component,finalCompilerOptions=extend(extend({isCustomElement,delimiters},compilerOptions),componentCompilerOptions);Component.render=compile$1(template,finalCompilerOptions)}}instance.render=Component.render||NOOP,installWithProxy&&installWithProxy(instance)}{setCurrentInstance(instance),pauseTracking();try{applyOptions(instance)}finally{resetTracking(),unsetCurrentInstance()}}}function getAttrsProxy(instance){return instance.attrsProxy||(instance.attrsProxy=new Proxy(instance.attrs,{get(target,key){return track(instance,"get","$attrs"),target[key]}}))}function createSetupContext(instance){const expose=exposed=>{instance.exposed=exposed||{}};return{get attrs(){return getAttrsProxy(instance)},slots:instance.slots,emit:instance.emit,expose}}function getExposeProxy(instance){if(instance.exposed)return instance.exposeProxy||(instance.exposeProxy=new Proxy(proxyRefs(markRaw(instance.exposed)),{get(target,key){if(key in target)return target[key];if(key in publicPropertiesMap)return publicPropertiesMap[key](instance)},has(target,key){return key in target||key in publicPropertiesMap}}))}function getComponentName(Component,includeInferred=!0){return isFunction(Component)?Component.displayName||Component.name:Component.name||includeInferred&&Component.__name}function isClassComponent(value){return isFunction(value)&&"__vccOpts"in value}const computed=(getterOrOptions,debugOptions)=>computed$1(getterOrOptions,debugOptions,isInSSRComponentSetup);function h(type,propsOrChildren,children){const l=arguments.length;return l===2?isObject(propsOrChildren)&&!isArray(propsOrChildren)?isVNode(propsOrChildren)?createVNode(type,null,[propsOrChildren]):createVNode(type,propsOrChildren):createVNode(type,null,propsOrChildren):(l>3?children=Array.prototype.slice.call(arguments,2):l===3&&isVNode(children)&&(children=[children]),createVNode(type,propsOrChildren,children))}const ssrContextKey=Symbol.for("v-scx"),useSSRContext=()=>inject(ssrContextKey);function initCustomFormatter(){}function withMemo(memo,render2,cache,index){const cached=cache[index];if(cached&&isMemoSame(cached,memo))return cached;const ret=render2();return ret.memo=memo.slice(),cache[index]=ret}function isMemoSame(cached,memo){const prev=cached.memo;if(prev.length!=memo.length)return!1;for(let i=0;i<prev.length;i++)if(hasChanged(prev[i],memo[i]))return!1;return isBlockTreeEnabled>0&&currentBlock&&currentBlock.push(cached),!0}const version="3.3.9",_ssrUtils={createComponentInstance,setupComponent,renderComponentRoot,setCurrentRenderingInstance,isVNode,normalizeVNode},ssrUtils=_ssrUtils,resolveFilter=null,compatUtils=null,svgNS="http://www.w3.org/2000/svg",doc=typeof document<"u"?document:null,templateContainer=doc&&doc.createElement("template"),nodeOps={insert:(child,parent,anchor)=>{parent.insertBefore(child,anchor||null)},remove:child=>{const parent=child.parentNode;parent&&parent.removeChild(child)},createElement:(tag,isSVG,is,props)=>{const el=isSVG?doc.createElementNS(svgNS,tag):doc.createElement(tag,is?{is}:void 0);return tag==="select"&&props&&props.multiple!=null&&el.setAttribute("multiple",props.multiple),el},createText:text=>doc.createTextNode(text),createComment:text=>doc.createComment(text),setText:(node,text)=>{node.nodeValue=text},setElementText:(el,text)=>{el.textContent=text},parentNode:node=>node.parentNode,nextSibling:node=>node.nextSibling,querySelector:selector=>doc.querySelector(selector),setScopeId(el,id){el.setAttribute(id,"")},insertStaticContent(content,parent,anchor,isSVG,start,end){const before=anchor?anchor.previousSibling:parent.lastChild;if(start&&(start===end||start.nextSibling))for(;parent.insertBefore(start.cloneNode(!0),anchor),!(start===end||!(start=start.nextSibling)););else{templateContainer.innerHTML=isSVG?`<svg>${content}</svg>`:content;const template=templateContainer.content;if(isSVG){const wrapper=template.firstChild;for(;wrapper.firstChild;)template.appendChild(wrapper.firstChild);template.removeChild(wrapper)}parent.insertBefore(template,anchor)}return[before?before.nextSibling:parent.firstChild,anchor?anchor.previousSibling:parent.lastChild]}},TRANSITION$1="transition",ANIMATION="animation",vtcKey=Symbol("_vtc"),Transition=(props,{slots})=>h(BaseTransition,resolveTransitionProps(props),slots);Transition.displayName="Transition";const DOMTransitionPropsValidators={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},TransitionPropsValidators=Transition.props=extend({},BaseTransitionPropsValidators,DOMTransitionPropsValidators),callHook=(hook,args=[])=>{isArray(hook)?hook.forEach(h2=>h2(...args)):hook&&hook(...args)},hasExplicitCallback=hook=>hook?isArray(hook)?hook.some(h2=>h2.length>1):hook.length>1:!1;function resolveTransitionProps(rawProps){const baseProps={};for(const key in rawProps)key in DOMTransitionPropsValidators||(baseProps[key]=rawProps[key]);if(rawProps.css===!1)return baseProps;const{name="v",type,duration,enterFromClass=`${name}-enter-from`,enterActiveClass=`${name}-enter-active`,enterToClass=`${name}-enter-to`,appearFromClass=enterFromClass,appearActiveClass=enterActiveClass,appearToClass=enterToClass,leaveFromClass=`${name}-leave-from`,leaveActiveClass=`${name}-leave-active`,leaveToClass=`${name}-leave-to`}=rawProps,durations=normalizeDuration(duration),enterDuration=durations&&durations[0],leaveDuration=durations&&durations[1],{onBeforeEnter,onEnter,onEnterCancelled,onLeave,onLeaveCancelled,onBeforeAppear=onBeforeEnter,onAppear=onEnter,onAppearCancelled=onEnterCancelled}=baseProps,finishEnter=(el,isAppear,done)=>{removeTransitionClass(el,isAppear?appearToClass:enterToClass),removeTransitionClass(el,isAppear?appearActiveClass:enterActiveClass),done&&done()},finishLeave=(el,done)=>{el._isLeaving=!1,removeTransitionClass(el,leaveFromClass),removeTransitionClass(el,leaveToClass),removeTransitionClass(el,leaveActiveClass),done&&done()},makeEnterHook=isAppear=>(el,done)=>{const hook=isAppear?onAppear:onEnter,resolve2=()=>finishEnter(el,isAppear,done);callHook(hook,[el,resolve2]),nextFrame(()=>{removeTransitionClass(el,isAppear?appearFromClass:enterFromClass),addTransitionClass(el,isAppear?appearToClass:enterToClass),hasExplicitCallback(hook)||whenTransitionEnds(el,type,enterDuration,resolve2)})};return extend(baseProps,{onBeforeEnter(el){callHook(onBeforeEnter,[el]),addTransitionClass(el,enterFromClass),addTransitionClass(el,enterActiveClass)},onBeforeAppear(el){callHook(onBeforeAppear,[el]),addTransitionClass(el,appearFromClass),addTransitionClass(el,appearActiveClass)},onEnter:makeEnterHook(!1),onAppear:makeEnterHook(!0),onLeave(el,done){el._isLeaving=!0;const resolve2=()=>finishLeave(el,done);addTransitionClass(el,leaveFromClass),forceReflow(),addTransitionClass(el,leaveActiveClass),nextFrame(()=>{el._isLeaving&&(removeTransitionClass(el,leaveFromClass),addTransitionClass(el,leaveToClass),hasExplicitCallback(onLeave)||whenTransitionEnds(el,type,leaveDuration,resolve2))}),callHook(onLeave,[el,resolve2])},onEnterCancelled(el){finishEnter(el,!1),callHook(onEnterCancelled,[el])},onAppearCancelled(el){finishEnter(el,!0),callHook(onAppearCancelled,[el])},onLeaveCancelled(el){finishLeave(el),callHook(onLeaveCancelled,[el])}})}function normalizeDuration(duration){if(duration==null)return null;if(isObject(duration))return[NumberOf(duration.enter),NumberOf(duration.leave)];{const n=NumberOf(duration);return[n,n]}}function NumberOf(val){return toNumber(val)}function addTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.add(c)),(el[vtcKey]||(el[vtcKey]=new Set)).add(cls)}function removeTransitionClass(el,cls){cls.split(/\s+/).forEach(c=>c&&el.classList.remove(c));const _vtc=el[vtcKey];_vtc&&(_vtc.delete(cls),_vtc.size||(el[vtcKey]=void 0))}function nextFrame(cb){requestAnimationFrame(()=>{requestAnimationFrame(cb)})}let endId=0;function whenTransitionEnds(el,expectedType,explicitTimeout,resolve2){const id=el._endId=++endId,resolveIfNotStale=()=>{id===el._endId&&resolve2()};if(explicitTimeout)return setTimeout(resolveIfNotStale,explicitTimeout);const{type,timeout,propCount}=getTransitionInfo(el,expectedType);if(!type)return resolve2();const endEvent=type+"end";let ended=0;const end=()=>{el.removeEventListener(endEvent,onEnd),resolveIfNotStale()},onEnd=e=>{e.target===el&&++ended>=propCount&&end()};setTimeout(()=>{ended<propCount&&end()},timeout+1),el.addEventListener(endEvent,onEnd)}function getTransitionInfo(el,expectedType){const styles=window.getComputedStyle(el),getStyleProperties=key=>(styles[key]||"").split(", "),transitionDelays=getStyleProperties(`${TRANSITION$1}Delay`),transitionDurations=getStyleProperties(`${TRANSITION$1}Duration`),transitionTimeout=getTimeout(transitionDelays,transitionDurations),animationDelays=getStyleProperties(`${ANIMATION}Delay`),animationDurations=getStyleProperties(`${ANIMATION}Duration`),animationTimeout=getTimeout(animationDelays,animationDurations);let type=null,timeout=0,propCount=0;expectedType===TRANSITION$1?transitionTimeout>0&&(type=TRANSITION$1,timeout=transitionTimeout,propCount=transitionDurations.length):expectedType===ANIMATION?animationTimeout>0&&(type=ANIMATION,timeout=animationTimeout,propCount=animationDurations.length):(timeout=Math.max(transitionTimeout,animationTimeout),type=timeout>0?transitionTimeout>animationTimeout?TRANSITION$1:ANIMATION:null,propCount=type?type===TRANSITION$1?transitionDurations.length:animationDurations.length:0);const hasTransform=type===TRANSITION$1&&/\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION$1}Property`).toString());return{type,timeout,propCount,hasTransform}}function getTimeout(delays,durations){for(;delays.length<durations.length;)delays=delays.concat(delays);return Math.max(...durations.map((d,i)=>toMs(d)+toMs(delays[i])))}function toMs(s){return s==="auto"?0:Number(s.slice(0,-1).replace(",","."))*1e3}function forceReflow(){return document.body.offsetHeight}function patchClass(el,value,isSVG){const transitionClasses=el[vtcKey];transitionClasses&&(value=(value?[value,...transitionClasses]:[...transitionClasses]).join(" ")),value==null?el.removeAttribute("class"):isSVG?el.setAttribute("class",value):el.className=value}const vShowOldKey=Symbol("_vod"),vShow={beforeMount(el,{value},{transition}){el[vShowOldKey]=el.style.display==="none"?"":el.style.display,transition&&value?transition.beforeEnter(el):setDisplay(el,value)},mounted(el,{value},{transition}){transition&&value&&transition.enter(el)},updated(el,{value,oldValue},{transition}){!value!=!oldValue&&(transition?value?(transition.beforeEnter(el),setDisplay(el,!0),transition.enter(el)):transition.leave(el,()=>{setDisplay(el,!1)}):setDisplay(el,value))},beforeUnmount(el,{value}){setDisplay(el,value)}};function setDisplay(el,value){el.style.display=value?el[vShowOldKey]:"none"}function initVShowForSSR(){vShow.getSSRProps=({value})=>{if(!value)return{style:{display:"none"}}}}function patchStyle(el,prev,next){const style=el.style,isCssString=isString(next);if(next&&!isCssString){if(prev&&!isString(prev))for(const key in prev)next[key]==null&&setStyle(style,key,"");for(const key in next)setStyle(style,key,next[key])}else{const currentDisplay=style.display;isCssString?prev!==next&&(style.cssText=next):prev&&el.removeAttribute("style"),vShowOldKey in el&&(style.display=currentDisplay)}}const importantRE=/\s*!important$/;function setStyle(style,name,val){if(isArray(val))val.forEach(v=>setStyle(style,name,v));else if(val==null&&(val=""),name.startsWith("--"))style.setProperty(name,val);else{const prefixed=autoPrefix(style,name);importantRE.test(val)?style.setProperty(hyphenate(prefixed),val.replace(importantRE,""),"important"):style[prefixed]=val}}const prefixes=["Webkit","Moz","ms"],prefixCache={};function autoPrefix(style,rawName){const cached=prefixCache[rawName];if(cached)return cached;let name=camelize(rawName);if(name!=="filter"&&name in style)return prefixCache[rawName]=name;name=capitalize(name);for(let i=0;i<prefixes.length;i++){const prefixed=prefixes[i]+name;if(prefixed in style)return prefixCache[rawName]=prefixed}return rawName}const xlinkNS="http://www.w3.org/1999/xlink";function patchAttr(el,key,value,isSVG,instance){if(isSVG&&key.startsWith("xlink:"))value==null?el.removeAttributeNS(xlinkNS,key.slice(6,key.length)):el.setAttributeNS(xlinkNS,key,value);else{const isBoolean=isSpecialBooleanAttr(key);value==null||isBoolean&&!includeBooleanAttr(value)?el.removeAttribute(key):el.setAttribute(key,isBoolean?"":value)}}function patchDOMProp(el,key,value,prevChildren,parentComponent,parentSuspense,unmountChildren){if(key==="innerHTML"||key==="textContent"){prevChildren&&unmountChildren(prevChildren,parentComponent,parentSuspense),el[key]=value??"";return}const tag=el.tagName;if(key==="value"&&tag!=="PROGRESS"&&!tag.includes("-")){el._value=value;const oldValue=tag==="OPTION"?el.getAttribute("value"):el.value,newValue=value??"";oldValue!==newValue&&(el.value=newValue),value==null&&el.removeAttribute(key);return}let needRemove=!1;if(value===""||value==null){const type=typeof el[key];type==="boolean"?value=includeBooleanAttr(value):value==null&&type==="string"?(value="",needRemove=!0):type==="number"&&(value=0,needRemove=!0)}try{el[key]=value}catch{}needRemove&&el.removeAttribute(key)}function addEventListener(el,event,handler,options){el.addEventListener(event,handler,options)}function removeEventListener(el,event,handler,options){el.removeEventListener(event,handler,options)}const veiKey=Symbol("_vei");function patchEvent(el,rawName,prevValue,nextValue,instance=null){const invokers=el[veiKey]||(el[veiKey]={}),existingInvoker=invokers[rawName];if(nextValue&&existingInvoker)existingInvoker.value=nextValue;else{const[name,options]=parseName(rawName);if(nextValue){const invoker=invokers[rawName]=createInvoker(nextValue,instance);addEventListener(el,name,invoker,options)}else existingInvoker&&(removeEventListener(el,name,existingInvoker,options),invokers[rawName]=void 0)}}const optionsModifierRE=/(?:Once|Passive|Capture)$/;function parseName(name){let options;if(optionsModifierRE.test(name)){options={};let m;for(;m=name.match(optionsModifierRE);)name=name.slice(0,name.length-m[0].length),options[m[0].toLowerCase()]=!0}return[name[2]===":"?name.slice(3):hyphenate(name.slice(2)),options]}let cachedNow=0;const p=Promise.resolve(),getNow=()=>cachedNow||(p.then(()=>cachedNow=0),cachedNow=Date.now());function createInvoker(initialValue,instance){const invoker=e=>{if(!e._vts)e._vts=Date.now();else if(e._vts<=invoker.attached)return;callWithAsyncErrorHandling(patchStopImmediatePropagation(e,invoker.value),instance,5,[e])};return invoker.value=initialValue,invoker.attached=getNow(),invoker}function patchStopImmediatePropagation(e,value){if(isArray(value)){const originalStop=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{originalStop.call(e),e._stopped=!0},value.map(fn=>e2=>!e2._stopped&&fn&&fn(e2))}else return value}const nativeOnRE=/^on[a-z]/,patchProp=(el,key,prevValue,nextValue,isSVG=!1,prevChildren,parentComponent,parentSuspense,unmountChildren)=>{key==="class"?patchClass(el,nextValue,isSVG):key==="style"?patchStyle(el,prevValue,nextValue):isOn(key)?isModelListener(key)||patchEvent(el,key,prevValue,nextValue,parentComponent):(key[0]==="."?(key=key.slice(1),!0):key[0]==="^"?(key=key.slice(1),!1):shouldSetAsProp(el,key,nextValue,isSVG))?patchDOMProp(el,key,nextValue,prevChildren,parentComponent,parentSuspense,unmountChildren):(key==="true-value"?el._trueValue=nextValue:key==="false-value"&&(el._falseValue=nextValue),patchAttr(el,key,nextValue,isSVG))};function shouldSetAsProp(el,key,value,isSVG){return isSVG?!!(key==="innerHTML"||key==="textContent"||key in el&&nativeOnRE.test(key)&&isFunction(value)):key==="spellcheck"||key==="draggable"||key==="translate"||key==="form"||key==="list"&&el.tagName==="INPUT"||key==="type"&&el.tagName==="TEXTAREA"||nativeOnRE.test(key)&&isString(value)?!1:key in el}/*! #__NO_SIDE_EFFECTS__ */function defineCustomElement(options,hydrate2){const Comp=defineComponent(options);class VueCustomElement extends VueElement{constructor(initialProps){super(Comp,initialProps,hydrate2)}}return VueCustomElement.def=Comp,VueCustomElement}/*! #__NO_SIDE_EFFECTS__ */const defineSSRCustomElement=options=>defineCustomElement(options,hydrate),BaseClass=typeof HTMLElement<"u"?HTMLElement:class{};class VueElement extends BaseClass{constructor(_def,_props={},hydrate2){super(),this._def=_def,this._props=_props,this._instance=null,this._connected=!1,this._resolved=!1,this._numberProps=null,this._ob=null,this.shadowRoot&&hydrate2?hydrate2(this._createVNode(),this.shadowRoot):(this.attachShadow({mode:"open"}),this._def.__asyncLoader||this._resolveProps(this._def))}connectedCallback(){this._connected=!0,this._instance||(this._resolved?this._update():this._resolveDef())}disconnectedCallback(){this._connected=!1,this._ob&&(this._ob.disconnect(),this._ob=null),nextTick(()=>{this._connected||(render(null,this.shadowRoot),this._instance=null)})}_resolveDef(){this._resolved=!0;for(let i=0;i<this.attributes.length;i++)this._setAttr(this.attributes[i].name);this._ob=new MutationObserver(mutations=>{for(const m of mutations)this._setAttr(m.attributeName)}),this._ob.observe(this,{attributes:!0});const resolve2=(def2,isAsync=!1)=>{const{props,styles}=def2;let numberProps;if(props&&!isArray(props))for(const key in props){const opt=props[key];(opt===Number||opt&&opt.type===Number)&&(key in this._props&&(this._props[key]=toNumber(this._props[key])),(numberProps||(numberProps=Object.create(null)))[camelize(key)]=!0)}this._numberProps=numberProps,isAsync&&this._resolveProps(def2),this._applyStyles(styles),this._update()},asyncDef=this._def.__asyncLoader;asyncDef?asyncDef().then(def2=>resolve2(def2,!0)):resolve2(this._def)}_resolveProps(def2){const{props}=def2,declaredPropKeys=isArray(props)?props:Object.keys(props||{});for(const key of Object.keys(this))key[0]!=="_"&&declaredPropKeys.includes(key)&&this._setProp(key,this[key],!0,!1);for(const key of declaredPropKeys.map(camelize))Object.defineProperty(this,key,{get(){return this._getProp(key)},set(val){this._setProp(key,val)}})}_setAttr(key){let value=this.getAttribute(key);const camelKey=camelize(key);this._numberProps&&this._numberProps[camelKey]&&(value=toNumber(value)),this._setProp(camelKey,value,!1)}_getProp(key){return this._props[key]}_setProp(key,val,shouldReflect=!0,shouldUpdate=!0){val!==this._props[key]&&(this._props[key]=val,shouldUpdate&&this._instance&&this._update(),shouldReflect&&(val===!0?this.setAttribute(hyphenate(key),""):typeof val=="string"||typeof val=="number"?this.setAttribute(hyphenate(key),val+""):val||this.removeAttribute(hyphenate(key))))}_update(){render(this._createVNode(),this.shadowRoot)}_createVNode(){const vnode=createVNode(this._def,extend({},this._props));return this._instance||(vnode.ce=instance=>{this._instance=instance,instance.isCE=!0;const dispatch=(event,args)=>{this.dispatchEvent(new CustomEvent(event,{detail:args}))};instance.emit=(event,...args)=>{dispatch(event,args),hyphenate(event)!==event&&dispatch(hyphenate(event),args)};let parent=this;for(;parent=parent&&(parent.parentNode||parent.host);)if(parent instanceof VueElement){instance.parent=parent._instance,instance.provides=parent._instance.provides;break}}),vnode}_applyStyles(styles){styles&&styles.forEach(css=>{const s=document.createElement("style");s.textContent=css,this.shadowRoot.appendChild(s)})}}function useCssModule(name="$style"){{const instance=getCurrentInstance();if(!instance)return EMPTY_OBJ;const modules=instance.type.__cssModules;if(!modules)return EMPTY_OBJ;const mod=modules[name];return mod||EMPTY_OBJ}}function useCssVars(getter){const instance=getCurrentInstance();if(!instance)return;const updateTeleports=instance.ut=(vars=getter(instance.proxy))=>{Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach(node=>setVarsOnNode(node,vars))},setVars=()=>{const vars=getter(instance.proxy);setVarsOnVNode(instance.subTree,vars),updateTeleports(vars)};watchPostEffect(setVars),onMounted(()=>{const ob=new MutationObserver(setVars);ob.observe(instance.subTree.el.parentNode,{childList:!0}),onUnmounted(()=>ob.disconnect())})}function setVarsOnVNode(vnode,vars){if(vnode.shapeFlag&128){const suspense=vnode.suspense;vnode=suspense.activeBranch,suspense.pendingBranch&&!suspense.isHydrating&&suspense.effects.push(()=>{setVarsOnVNode(suspense.activeBranch,vars)})}for(;vnode.component;)vnode=vnode.component.subTree;if(vnode.shapeFlag&1&&vnode.el)setVarsOnNode(vnode.el,vars);else if(vnode.type===Fragment)vnode.children.forEach(c=>setVarsOnVNode(c,vars));else if(vnode.type===Static){let{el,anchor}=vnode;for(;el&&(setVarsOnNode(el,vars),el!==anchor);)el=el.nextSibling}}function setVarsOnNode(el,vars){if(el.nodeType===1){const style=el.style;for(const key in vars)style.setProperty(`--${key}`,vars[key])}}const positionMap=new WeakMap,newPositionMap=new WeakMap,moveCbKey=Symbol("_moveCb"),enterCbKey=Symbol("_enterCb"),TransitionGroupImpl={name:"TransitionGroup",props:extend({},TransitionPropsValidators,{tag:String,moveClass:String}),setup(props,{slots}){const instance=getCurrentInstance(),state=useTransitionState();let prevChildren,children;return onUpdated(()=>{if(!prevChildren.length)return;const moveClass=props.moveClass||`${props.name||"v"}-move`;if(!hasCSSTransform(prevChildren[0].el,instance.vnode.el,moveClass))return;prevChildren.forEach(callPendingCbs),prevChildren.forEach(recordPosition);const movedChildren=prevChildren.filter(applyTranslation);forceReflow(),movedChildren.forEach(c=>{const el=c.el,style=el.style;addTransitionClass(el,moveClass),style.transform=style.webkitTransform=style.transitionDuration="";const cb=el[moveCbKey]=e=>{e&&e.target!==el||(!e||/transform$/.test(e.propertyName))&&(el.removeEventListener("transitionend",cb),el[moveCbKey]=null,removeTransitionClass(el,moveClass))};el.addEventListener("transitionend",cb)})}),()=>{const rawProps=toRaw(props),cssTransitionProps=resolveTransitionProps(rawProps);let tag=rawProps.tag||Fragment;prevChildren=children,children=slots.default?getTransitionRawChildren(slots.default()):[];for(let i=0;i<children.length;i++){const child=children[i];child.key!=null&&setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance))}if(prevChildren)for(let i=0;i<prevChildren.length;i++){const child=prevChildren[i];setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance)),positionMap.set(child,child.el.getBoundingClientRect())}return createVNode(tag,null,children)}}},removeMode=props=>delete props.mode;TransitionGroupImpl.props;const TransitionGroup=TransitionGroupImpl;function callPendingCbs(c){const el=c.el;el[moveCbKey]&&el[moveCbKey](),el[enterCbKey]&&el[enterCbKey]()}function recordPosition(c){newPositionMap.set(c,c.el.getBoundingClientRect())}function applyTranslation(c){const oldPos=positionMap.get(c),newPos=newPositionMap.get(c),dx=oldPos.left-newPos.left,dy=oldPos.top-newPos.top;if(dx||dy){const s=c.el.style;return s.transform=s.webkitTransform=`translate(${dx}px,${dy}px)`,s.transitionDuration="0s",c}}function hasCSSTransform(el,root,moveClass){const clone=el.cloneNode(),_vtc=el[vtcKey];_vtc&&_vtc.forEach(cls=>{cls.split(/\s+/).forEach(c=>c&&clone.classList.remove(c))}),moveClass.split(/\s+/).forEach(c=>c&&clone.classList.add(c)),clone.style.display="none";const container=root.nodeType===1?root:root.parentNode;container.appendChild(clone);const{hasTransform}=getTransitionInfo(clone);return container.removeChild(clone),hasTransform}const getModelAssigner=vnode=>{const fn=vnode.props["onUpdate:modelValue"]||!1;return isArray(fn)?value=>invokeArrayFns(fn,value):fn};function onCompositionStart(e){e.target.composing=!0}function onCompositionEnd(e){const target=e.target;target.composing&&(target.composing=!1,target.dispatchEvent(new Event("input")))}const assignKey=Symbol("_assign"),vModelText={created(el,{modifiers:{lazy,trim,number}},vnode){el[assignKey]=getModelAssigner(vnode);const castToNumber=number||vnode.props&&vnode.props.type==="number";addEventListener(el,lazy?"change":"input",e=>{if(e.target.composing)return;let domValue=el.value;trim&&(domValue=domValue.trim()),castToNumber&&(domValue=looseToNumber(domValue)),el[assignKey](domValue)}),trim&&addEventListener(el,"change",()=>{el.value=el.value.trim()}),lazy||(addEventListener(el,"compositionstart",onCompositionStart),addEventListener(el,"compositionend",onCompositionEnd),addEventListener(el,"change",onCompositionEnd))},mounted(el,{value}){el.value=value??""},beforeUpdate(el,{value,modifiers:{lazy,trim,number}},vnode){if(el[assignKey]=getModelAssigner(vnode),el.composing)return;const elValue=number||el.type==="number"?looseToNumber(el.value):el.value,newValue=value??"";elValue!==newValue&&(document.activeElement===el&&el.type!=="range"&&(lazy||trim&&el.value.trim()===newValue)||(el.value=newValue))}},vModelCheckbox={deep:!0,created(el,_,vnode){el[assignKey]=getModelAssigner(vnode),addEventListener(el,"change",()=>{const modelValue=el._modelValue,elementValue=getValue(el),checked=el.checked,assign=el[assignKey];if(isArray(modelValue)){const index=looseIndexOf(modelValue,elementValue),found=index!==-1;if(checked&&!found)assign(modelValue.concat(elementValue));else if(!checked&&found){const filtered=[...modelValue];filtered.splice(index,1),assign(filtered)}}else if(isSet(modelValue)){const cloned=new Set(modelValue);checked?cloned.add(elementValue):cloned.delete(elementValue),assign(cloned)}else assign(getCheckboxValue(el,checked))})},mounted:setChecked,beforeUpdate(el,binding,vnode){el[assignKey]=getModelAssigner(vnode),setChecked(el,binding,vnode)}};function setChecked(el,{value,oldValue},vnode){el._modelValue=value,isArray(value)?el.checked=looseIndexOf(value,vnode.props.value)>-1:isSet(value)?el.checked=value.has(vnode.props.value):value!==oldValue&&(el.checked=looseEqual(value,getCheckboxValue(el,!0)))}const vModelRadio={created(el,{value},vnode){el.checked=looseEqual(value,vnode.props.value),el[assignKey]=getModelAssigner(vnode),addEventListener(el,"change",()=>{el[assignKey](getValue(el))})},beforeUpdate(el,{value,oldValue},vnode){el[assignKey]=getModelAssigner(vnode),value!==oldValue&&(el.checked=looseEqual(value,vnode.props.value))}},vModelSelect={deep:!0,created(el,{value,modifiers:{number}},vnode){const isSetModel=isSet(value);addEventListener(el,"change",()=>{const selectedVal=Array.prototype.filter.call(el.options,o=>o.selected).map(o=>number?looseToNumber(getValue(o)):getValue(o));el[assignKey](el.multiple?isSetModel?new Set(selectedVal):selectedVal:selectedVal[0])}),el[assignKey]=getModelAssigner(vnode)},mounted(el,{value}){setSelected(el,value)},beforeUpdate(el,_binding,vnode){el[assignKey]=getModelAssigner(vnode)},updated(el,{value}){setSelected(el,value)}};function setSelected(el,value){const isMultiple=el.multiple;if(!(isMultiple&&!isArray(value)&&!isSet(value))){for(let i=0,l=el.options.length;i<l;i++){const option=el.options[i],optionValue=getValue(option);if(isMultiple)isArray(value)?option.selected=looseIndexOf(value,optionValue)>-1:option.selected=value.has(optionValue);else if(looseEqual(getValue(option),value)){el.selectedIndex!==i&&(el.selectedIndex=i);return}}!isMultiple&&el.selectedIndex!==-1&&(el.selectedIndex=-1)}}function getValue(el){return"_value"in el?el._value:el.value}function getCheckboxValue(el,checked){const key=checked?"_trueValue":"_falseValue";return key in el?el[key]:checked}const vModelDynamic={created(el,binding,vnode){callModelHook(el,binding,vnode,null,"created")},mounted(el,binding,vnode){callModelHook(el,binding,vnode,null,"mounted")},beforeUpdate(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"beforeUpdate")},updated(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,"updated")}};function resolveDynamicModel(tagName,type){switch(tagName){case"SELECT":return vModelSelect;case"TEXTAREA":return vModelText;default:switch(type){case"checkbox":return vModelCheckbox;case"radio":return vModelRadio;default:return vModelText}}}function callModelHook(el,binding,vnode,prevVNode,hook){const fn=resolveDynamicModel(el.tagName,vnode.props&&vnode.props.type)[hook];fn&&fn(el,binding,vnode,prevVNode)}function initVModelForSSR(){vModelText.getSSRProps=({value})=>({value}),vModelRadio.getSSRProps=({value},vnode)=>{if(vnode.props&&looseEqual(vnode.props.value,value))return{checked:!0}},vModelCheckbox.getSSRProps=({value},vnode)=>{if(isArray(value)){if(vnode.props&&looseIndexOf(value,vnode.props.value)>-1)return{checked:!0}}else if(isSet(value)){if(vnode.props&&value.has(vnode.props.value))return{checked:!0}}else if(value)return{checked:!0}},vModelDynamic.getSSRProps=(binding,vnode)=>{if(typeof vnode.type!="string")return;const modelToUse=resolveDynamicModel(vnode.type.toUpperCase(),vnode.props&&vnode.props.type);if(modelToUse.getSSRProps)return modelToUse.getSSRProps(binding,vnode)}}const systemModifiers=["ctrl","shift","alt","meta"],modifierGuards={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,modifiers)=>systemModifiers.some(m=>e[`${m}Key`]&&!modifiers.includes(m))},withModifiers=(fn,modifiers)=>(event,...args)=>{for(let i=0;i<modifiers.length;i++){const guard=modifierGuards[modifiers[i]];if(guard&&guard(event,modifiers))return}return fn(event,...args)},keyNames={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},withKeys=(fn,modifiers)=>event=>{if(!("key"in event))return;const eventKey=hyphenate(event.key);if(modifiers.some(k=>k===eventKey||keyNames[k]===eventKey))return fn(event)},rendererOptions=extend({patchProp},nodeOps);let renderer,enabledHydration=!1;function ensureRenderer(){return renderer||(renderer=createRenderer(rendererOptions))}function ensureHydrationRenderer(){return renderer=enabledHydration?renderer:createHydrationRenderer(rendererOptions),enabledHydration=!0,renderer}const render=(...args)=>{ensureRenderer().render(...args)},hydrate=(...args)=>{ensureHydrationRenderer().hydrate(...args)},createApp=(...args)=>{const app=ensureRenderer().createApp(...args),{mount}=app;return app.mount=containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(!container)return;const component=app._component;!isFunction(component)&&!component.render&&!component.template&&(component.template=container.innerHTML),container.innerHTML="";const proxy=mount(container,!1,container instanceof SVGElement);return container instanceof Element&&(container.removeAttribute("v-cloak"),container.setAttribute("data-v-app","")),proxy},app},createSSRApp=(...args)=>{const app=ensureHydrationRenderer().createApp(...args),{mount}=app;return app.mount=containerOrSelector=>{const container=normalizeContainer(containerOrSelector);if(container)return mount(container,!0,container instanceof SVGElement)},app};function normalizeContainer(container){return isString(container)?document.querySelector(container):container}let ssrDirectiveInitialized=!1;const initDirectivesForSSR=()=>{ssrDirectiveInitialized||(ssrDirectiveInitialized=!0,initVModelForSSR(),initVShowForSSR())},runtimeDom=Object.freeze(Object.defineProperty({__proto__:null,BaseTransition,BaseTransitionPropsValidators,Comment,EffectScope,Fragment,KeepAlive,ReactiveEffect,Static,Suspense,Teleport,Text,Transition,TransitionGroup,VueElement,assertNumber,callWithAsyncErrorHandling,callWithErrorHandling,camelize,capitalize,cloneVNode,compatUtils,computed,createApp,createBlock,createCommentVNode,createElementBlock,createElementVNode:createBaseVNode,createHydrationRenderer,createPropsRestProxy,createRenderer,createSSRApp,createSlots,createStaticVNode,createTextVNode,createVNode,customRef,defineAsyncComponent,defineComponent,defineCustomElement,defineEmits,defineExpose,defineModel,defineOptions,defineProps,defineSSRCustomElement,defineSlots,get devtools(){return devtools},effect,effectScope,getCurrentInstance,getCurrentScope,getTransitionRawChildren,guardReactiveProps,h,handleError,hasInjectionContext,hydrate,initCustomFormatter,initDirectivesForSSR,inject,isMemoSame,isProxy,isReactive,isReadonly,isRef,isRuntimeOnly,isShallow,isVNode,markRaw,mergeDefaults,mergeModels,mergeProps,nextTick,normalizeClass,normalizeProps,normalizeStyle,onActivated,onBeforeMount,onBeforeUnmount,onBeforeUpdate,onDeactivated,onErrorCaptured,onMounted,onRenderTracked,onRenderTriggered,onScopeDispose,onServerPrefetch,onUnmounted,onUpdated,openBlock,popScopeId,provide,proxyRefs,pushScopeId,queuePostFlushCb,reactive,readonly,ref,registerRuntimeCompiler,render,renderList,renderSlot,resolveComponent,resolveDirective,resolveDynamicComponent,resolveFilter,resolveTransitionHooks,setBlockTracking,setDevtoolsHook,setTransitionHooks,shallowReactive,shallowReadonly,shallowRef,ssrContextKey,ssrUtils,stop,toDisplayString,toHandlerKey,toHandlers,toRaw,toRef,toRefs,toValue,transformVNodeArgs,triggerRef,unref,useAttrs,useCssModule,useCssVars,useModel,useSSRContext,useSlots,useTransitionState,vModelCheckbox,vModelDynamic,vModelRadio,vModelSelect,vModelText,vShow,version,warn,watch,watchEffect,watchPostEffect,watchSyncEffect,withAsyncContext,withCtx,withDefaults,withDirectives,withKeys,withMemo,withModifiers,withScopeId},Symbol.toStringTag,{value:"Module"}));function defaultOnError(error){throw error}function defaultOnWarn(msg){}function createCompilerError(code,loc,messages,additionalMessage){const msg=code,error=new SyntaxError(String(msg));return error.code=code,error.loc=loc,error}const FRAGMENT=Symbol(""),TELEPORT=Symbol(""),SUSPENSE=Symbol(""),KEEP_ALIVE=Symbol(""),BASE_TRANSITION=Symbol(""),OPEN_BLOCK=Symbol(""),CREATE_BLOCK=Symbol(""),CREATE_ELEMENT_BLOCK=Symbol(""),CREATE_VNODE=Symbol(""),CREATE_ELEMENT_VNODE=Symbol(""),CREATE_COMMENT=Symbol(""),CREATE_TEXT=Symbol(""),CREATE_STATIC=Symbol(""),RESOLVE_COMPONENT=Symbol(""),RESOLVE_DYNAMIC_COMPONENT=Symbol(""),RESOLVE_DIRECTIVE=Symbol(""),RESOLVE_FILTER=Symbol(""),WITH_DIRECTIVES=Symbol(""),RENDER_LIST=Symbol(""),RENDER_SLOT=Symbol(""),CREATE_SLOTS=Symbol(""),TO_DISPLAY_STRING=Symbol(""),MERGE_PROPS=Symbol(""),NORMALIZE_CLASS=Symbol(""),NORMALIZE_STYLE=Symbol(""),NORMALIZE_PROPS=Symbol(""),GUARD_REACTIVE_PROPS=Symbol(""),TO_HANDLERS=Symbol(""),CAMELIZE=Symbol(""),CAPITALIZE=Symbol(""),TO_HANDLER_KEY=Symbol(""),SET_BLOCK_TRACKING=Symbol(""),PUSH_SCOPE_ID=Symbol(""),POP_SCOPE_ID=Symbol(""),WITH_CTX=Symbol(""),UNREF=Symbol(""),IS_REF=Symbol(""),WITH_MEMO=Symbol(""),IS_MEMO_SAME=Symbol(""),helperNameMap={[FRAGMENT]:"Fragment",[TELEPORT]:"Teleport",[SUSPENSE]:"Suspense",[KEEP_ALIVE]:"KeepAlive",[BASE_TRANSITION]:"BaseTransition",[OPEN_BLOCK]:"openBlock",[CREATE_BLOCK]:"createBlock",[CREATE_ELEMENT_BLOCK]:"createElementBlock",[CREATE_VNODE]:"createVNode",[CREATE_ELEMENT_VNODE]:"createElementVNode",[CREATE_COMMENT]:"createCommentVNode",[CREATE_TEXT]:"createTextVNode",[CREATE_STATIC]:"createStaticVNode",[RESOLVE_COMPONENT]:"resolveComponent",[RESOLVE_DYNAMIC_COMPONENT]:"resolveDynamicComponent",[RESOLVE_DIRECTIVE]:"resolveDirective",[RESOLVE_FILTER]:"resolveFilter",[WITH_DIRECTIVES]:"withDirectives",[RENDER_LIST]:"renderList",[RENDER_SLOT]:"renderSlot",[CREATE_SLOTS]:"createSlots",[TO_DISPLAY_STRING]:"toDisplayString",[MERGE_PROPS]:"mergeProps",[NORMALIZE_CLASS]:"normalizeClass",[NORMALIZE_STYLE]:"normalizeStyle",[NORMALIZE_PROPS]:"normalizeProps",[GUARD_REACTIVE_PROPS]:"guardReactiveProps",[TO_HANDLERS]:"toHandlers",[CAMELIZE]:"camelize",[CAPITALIZE]:"capitalize",[TO_HANDLER_KEY]:"toHandlerKey",[SET_BLOCK_TRACKING]:"setBlockTracking",[PUSH_SCOPE_ID]:"pushScopeId",[POP_SCOPE_ID]:"popScopeId",[WITH_CTX]:"withCtx",[UNREF]:"unref",[IS_REF]:"isRef",[WITH_MEMO]:"withMemo",[IS_MEMO_SAME]:"isMemoSame"};function registerRuntimeHelpers(helpers){Object.getOwnPropertySymbols(helpers).forEach(s=>{helperNameMap[s]=helpers[s]})}const locStub={source:"",start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}};function createRoot(children,loc=locStub){return{type:0,children,helpers:new Set,components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:void 0,loc}}function createVNodeCall(context,tag,props,children,patchFlag,dynamicProps,directives,isBlock=!1,disableTracking=!1,isComponent2=!1,loc=locStub){return context&&(isBlock?(context.helper(OPEN_BLOCK),context.helper(getVNodeBlockHelper(context.inSSR,isComponent2))):context.helper(getVNodeHelper(context.inSSR,isComponent2)),directives&&context.helper(WITH_DIRECTIVES)),{type:13,tag,props,children,patchFlag,dynamicProps,directives,isBlock,disableTracking,isComponent:isComponent2,loc}}function createArrayExpression(elements,loc=locStub){return{type:17,loc,elements}}function createObjectExpression(properties,loc=locStub){return{type:15,loc,properties}}function createObjectProperty(key,value){return{type:16,loc:locStub,key:isString(key)?createSimpleExpression(key,!0):key,value}}function createSimpleExpression(content,isStatic=!1,loc=locStub,constType=0){return{type:4,loc,content,isStatic,constType:isStatic?3:constType}}function createCompoundExpression(children,loc=locStub){return{type:8,loc,children}}function createCallExpression(callee,args=[],loc=locStub){return{type:14,loc,callee,arguments:args}}function createFunctionExpression(params,returns=void 0,newline=!1,isSlot=!1,loc=locStub){return{type:18,params,returns,newline,isSlot,loc}}function createConditionalExpression(test,consequent,alternate,newline=!0){return{type:19,test,consequent,alternate,newline,loc:locStub}}function createCacheExpression(index,value,isVNode2=!1){return{type:20,index,value,isVNode:isVNode2,loc:locStub}}function createBlockStatement(body){return{type:21,body,loc:locStub}}function getVNodeHelper(ssr,isComponent2){return ssr||isComponent2?CREATE_VNODE:CREATE_ELEMENT_VNODE}function getVNodeBlockHelper(ssr,isComponent2){return ssr||isComponent2?CREATE_BLOCK:CREATE_ELEMENT_BLOCK}function convertToBlock(node,{helper,removeHelper,inSSR}){node.isBlock||(node.isBlock=!0,removeHelper(getVNodeHelper(inSSR,node.isComponent)),helper(OPEN_BLOCK),helper(getVNodeBlockHelper(inSSR,node.isComponent)))}const isStaticExp=p2=>p2.type===4&&p2.isStatic,isBuiltInType=(tag,expected)=>tag===expected||tag===hyphenate(expected);function isCoreComponent(tag){if(isBuiltInType(tag,"Teleport"))return TELEPORT;if(isBuiltInType(tag,"Suspense"))return SUSPENSE;if(isBuiltInType(tag,"KeepAlive"))return KEEP_ALIVE;if(isBuiltInType(tag,"BaseTransition"))return BASE_TRANSITION}const nonIdentifierRE=/^\d|[^\$\w]/,isSimpleIdentifier=name=>!nonIdentifierRE.test(name),validFirstIdentCharRE=/[A-Za-z_$\xA0-\uFFFF]/,validIdentCharRE=/[\.\?\w$\xA0-\uFFFF]/,whitespaceRE=/\s+[.[]\s*|\s*[.[]\s+/g,isMemberExpressionBrowser=path=>{path=path.trim().replace(whitespaceRE,s=>s.trim());let state=0,stateStack=[],currentOpenBracketCount=0,currentOpenParensCount=0,currentStringType=null;for(let i=0;i<path.length;i++){const char=path.charAt(i);switch(state){case 0:if(char==="[")stateStack.push(state),state=1,currentOpenBracketCount++;else if(char==="(")stateStack.push(state),state=2,currentOpenParensCount++;else if(!(i===0?validFirstIdentCharRE:validIdentCharRE).test(char))return!1;break;case 1:char==="'"||char==='"'||char==="`"?(stateStack.push(state),state=3,currentStringType=char):char==="["?currentOpenBracketCount++:char==="]"&&(--currentOpenBracketCount||(state=stateStack.pop()));break;case 2:if(char==="'"||char==='"'||char==="`")stateStack.push(state),state=3,currentStringType=char;else if(char==="(")currentOpenParensCount++;else if(char===")"){if(i===path.length-1)return!1;--currentOpenParensCount||(state=stateStack.pop())}break;case 3:char===currentStringType&&(state=stateStack.pop(),currentStringType=null);break}}return!currentOpenBracketCount&&!currentOpenParensCount},isMemberExpression=isMemberExpressionBrowser;function getInnerRange(loc,offset,length){const newLoc={source:loc.source.slice(offset,offset+length),start:advancePositionWithClone(loc.start,loc.source,offset),end:loc.end};return length!=null&&(newLoc.end=advancePositionWithClone(loc.start,loc.source,offset+length)),newLoc}function advancePositionWithClone(pos,source,numberOfCharacters=source.length){return advancePositionWithMutation(extend({},pos),source,numberOfCharacters)}function advancePositionWithMutation(pos,source,numberOfCharacters=source.length){let linesCount=0,lastNewLinePos=-1;for(let i=0;i<numberOfCharacters;i++)source.charCodeAt(i)===10&&(linesCount++,lastNewLinePos=i);return pos.offset+=numberOfCharacters,pos.line+=linesCount,pos.column=lastNewLinePos===-1?pos.column+numberOfCharacters:numberOfCharacters-lastNewLinePos,pos}function findDir(node,name,allowEmpty=!1){for(let i=0;i<node.props.length;i++){const p2=node.props[i];if(p2.type===7&&(allowEmpty||p2.exp)&&(isString(name)?p2.name===name:name.test(p2.name)))return p2}}function findProp(node,name,dynamicOnly=!1,allowEmpty=!1){for(let i=0;i<node.props.length;i++){const p2=node.props[i];if(p2.type===6){if(dynamicOnly)continue;if(p2.name===name&&(p2.value||allowEmpty))return p2}else if(p2.name==="bind"&&(p2.exp||allowEmpty)&&isStaticArgOf(p2.arg,name))return p2}}function isStaticArgOf(arg,name){return!!(arg&&isStaticExp(arg)&&arg.content===name)}function hasDynamicKeyVBind(node){return node.props.some(p2=>p2.type===7&&p2.name==="bind"&&(!p2.arg||p2.arg.type!==4||!p2.arg.isStatic))}function isText$1(node){return node.type===5||node.type===2}function isVSlot(p2){return p2.type===7&&p2.name==="slot"}function isTemplateNode(node){return node.type===1&&node.tagType===3}function isSlotOutlet(node){return node.type===1&&node.tagType===2}const propsHelperSet=new Set([NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]);function getUnnormalizedProps(props,callPath=[]){if(props&&!isString(props)&&props.type===14){const callee=props.callee;if(!isString(callee)&&propsHelperSet.has(callee))return getUnnormalizedProps(props.arguments[0],callPath.concat(props))}return[props,callPath]}function injectProp(node,prop,context){let propsWithInjection,props=node.type===13?node.props:node.arguments[2],callPath=[],parentCall;if(props&&!isString(props)&&props.type===14){const ret=getUnnormalizedProps(props);props=ret[0],callPath=ret[1],parentCall=callPath[callPath.length-1]}if(props==null||isString(props))propsWithInjection=createObjectExpression([prop]);else if(props.type===14){const first=props.arguments[0];!isString(first)&&first.type===15?hasProp(prop,first)||first.properties.unshift(prop):props.callee===TO_HANDLERS?propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]):props.arguments.unshift(createObjectExpression([prop])),!propsWithInjection&&(propsWithInjection=props)}else props.type===15?(hasProp(prop,props)||props.properties.unshift(prop),propsWithInjection=props):(propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]),parentCall&&parentCall.callee===GUARD_REACTIVE_PROPS&&(parentCall=callPath[callPath.length-2]));node.type===13?parentCall?parentCall.arguments[0]=propsWithInjection:node.props=propsWithInjection:parentCall?parentCall.arguments[0]=propsWithInjection:node.arguments[2]=propsWithInjection}function hasProp(prop,props){let result=!1;if(prop.key.type===4){const propKeyName=prop.key.content;result=props.properties.some(p2=>p2.key.type===4&&p2.key.content===propKeyName)}return result}function toValidAssetId(name,type){return`_${type}_${name.replace(/[^\w]/g,(searchValue,replaceValue)=>searchValue==="-"?"_":name.charCodeAt(replaceValue).toString())}`}function getMemoedVNodeCall(node){return node.type===14&&node.callee===WITH_MEMO?node.arguments[1].returns:node}const forAliasRE=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;function getCompatValue(key,context){const config=context.options?context.options.compatConfig:context.compatConfig,value=config&&config[key];return key==="MODE"?value||3:value}function isCompatEnabled(key,context){const mode=getCompatValue("MODE",context),value=getCompatValue(key,context);return mode===3?value===!0:value!==!1}function checkCompatEnabled(key,context,loc,...args){return isCompatEnabled(key,context)}const decodeRE=/&(gt|lt|amp|apos|quot);/g,decodeMap={gt:">",lt:"<",amp:"&",apos:"'",quot:'"'},defaultParserOptions={delimiters:["{{","}}"],getNamespace:()=>0,getTextMode:()=>0,isVoidTag:NO,isPreTag:NO,isCustomElement:NO,decodeEntities:rawText=>rawText.replace(decodeRE,(_,p1)=>decodeMap[p1]),onError:defaultOnError,onWarn:defaultOnWarn,comments:!1};function baseParse(content,options={}){const context=createParserContext(content,options),start=getCursor(context);return createRoot(parseChildren(context,0,[]),getSelection(context,start))}function createParserContext(content,rawOptions){const options=extend({},defaultParserOptions);let key;for(key in rawOptions)options[key]=rawOptions[key]===void 0?defaultParserOptions[key]:rawOptions[key];return{options,column:1,line:1,offset:0,originalSource:content,source:content,inPre:!1,inVPre:!1,onWarn:options.onWarn}}function parseChildren(context,mode,ancestors){const parent=last(ancestors),ns=parent?parent.ns:0,nodes=[];for(;!isEnd(context,mode,ancestors);){const s=context.source;let node;if(mode===0||mode===1){if(!context.inVPre&&startsWith(s,context.options.delimiters[0]))node=parseInterpolation(context,mode);else if(mode===0&&s[0]==="<")if(s.length===1)emitError(context,5,1);else if(s[1]==="!")startsWith(s,"<!--")?node=parseComment(context):startsWith(s,"<!DOCTYPE")?node=parseBogusComment(context):startsWith(s,"<![CDATA[")?ns!==0?node=parseCDATA(context,ancestors):(emitError(context,1),node=parseBogusComment(context)):(emitError(context,11),node=parseBogusComment(context));else if(s[1]==="/")if(s.length===2)emitError(context,5,2);else if(s[2]===">"){emitError(context,14,2),advanceBy(context,3);continue}else if(/[a-z]/i.test(s[2])){emitError(context,23),parseTag(context,1,parent);continue}else emitError(context,12,2),node=parseBogusComment(context);else/[a-z]/i.test(s[1])?(node=parseElement(context,ancestors),isCompatEnabled("COMPILER_NATIVE_TEMPLATE",context)&&node&&node.tag==="template"&&!node.props.some(p2=>p2.type===7&&isSpecialTemplateDirective(p2.name))&&(node=node.children)):s[1]==="?"?(emitError(context,21,1),node=parseBogusComment(context)):emitError(context,12,1)}if(node||(node=parseText(context,mode)),isArray(node))for(let i=0;i<node.length;i++)pushNode(nodes,node[i]);else pushNode(nodes,node)}let removedWhitespace=!1;if(mode!==2&&mode!==1){const shouldCondense=context.options.whitespace!=="preserve";for(let i=0;i<nodes.length;i++){const node=nodes[i];if(node.type===2)if(context.inPre)node.content=node.content.replace(/\r\n/g,`
`);else if(/[^\t\r\n\f ]/.test(node.content))shouldCondense&&(node.content=node.content.replace(/[\t\r\n\f ]+/g," "));else{const prev=nodes[i-1],next=nodes[i+1];!prev||!next||shouldCondense&&(prev.type===3&&next.type===3||prev.type===3&&next.type===1||prev.type===1&&next.type===3||prev.type===1&&next.type===1&&/[\r\n]/.test(node.content))?(removedWhitespace=!0,nodes[i]=null):node.content=" "}else node.type===3&&!context.options.comments&&(removedWhitespace=!0,nodes[i]=null)}if(context.inPre&&parent&&context.options.isPreTag(parent.tag)){const first=nodes[0];first&&first.type===2&&(first.content=first.content.replace(/^\r?\n/,""))}}return removedWhitespace?nodes.filter(Boolean):nodes}function pushNode(nodes,node){if(node.type===2){const prev=last(nodes);if(prev&&prev.type===2&&prev.loc.end.offset===node.loc.start.offset){prev.content+=node.content,prev.loc.end=node.loc.end,prev.loc.source+=node.loc.source;return}}nodes.push(node)}function parseCDATA(context,ancestors){advanceBy(context,9);const nodes=parseChildren(context,3,ancestors);return context.source.length===0?emitError(context,6):advanceBy(context,3),nodes}function parseComment(context){const start=getCursor(context);let content;const match=/--(\!)?>/.exec(context.source);if(!match)content=context.source.slice(4),advanceBy(context,context.source.length),emitError(context,7);else{match.index<=3&&emitError(context,0),match[1]&&emitError(context,10),content=context.source.slice(4,match.index);const s=context.source.slice(0,match.index);let prevIndex=1,nestedIndex=0;for(;(nestedIndex=s.indexOf("<!--",prevIndex))!==-1;)advanceBy(context,nestedIndex-prevIndex+1),nestedIndex+4<s.length&&emitError(context,16),prevIndex=nestedIndex+1;advanceBy(context,match.index+match[0].length-prevIndex+1)}return{type:3,content,loc:getSelection(context,start)}}function parseBogusComment(context){const start=getCursor(context),contentStart=context.source[1]==="?"?1:2;let content;const closeIndex=context.source.indexOf(">");return closeIndex===-1?(content=context.source.slice(contentStart),advanceBy(context,context.source.length)):(content=context.source.slice(contentStart,closeIndex),advanceBy(context,closeIndex+1)),{type:3,content,loc:getSelection(context,start)}}function parseElement(context,ancestors){const wasInPre=context.inPre,wasInVPre=context.inVPre,parent=last(ancestors),element=parseTag(context,0,parent),isPreBoundary=context.inPre&&!wasInPre,isVPreBoundary=context.inVPre&&!wasInVPre;if(element.isSelfClosing||context.options.isVoidTag(element.tag))return isPreBoundary&&(context.inPre=!1),isVPreBoundary&&(context.inVPre=!1),element;ancestors.push(element);const mode=context.options.getTextMode(element,parent),children=parseChildren(context,mode,ancestors);ancestors.pop();{const inlineTemplateProp=element.props.find(p2=>p2.type===6&&p2.name==="inline-template");if(inlineTemplateProp&&checkCompatEnabled("COMPILER_INLINE_TEMPLATE",context,inlineTemplateProp.loc)){const loc=getSelection(context,element.loc.end);inlineTemplateProp.value={type:2,content:loc.source,loc}}}if(element.children=children,startsWithEndTagOpen(context.source,element.tag))parseTag(context,1,parent);else if(emitError(context,24,0,element.loc.start),context.source.length===0&&element.tag.toLowerCase()==="script"){const first=children[0];first&&startsWith(first.loc.source,"<!--")&&emitError(context,8)}return element.loc=getSelection(context,element.loc.start),isPreBoundary&&(context.inPre=!1),isVPreBoundary&&(context.inVPre=!1),element}const isSpecialTemplateDirective=makeMap("if,else,else-if,for,slot");function parseTag(context,type,parent){const start=getCursor(context),match=/^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source),tag=match[1],ns=context.options.getNamespace(tag,parent);advanceBy(context,match[0].length),advanceSpaces(context);const cursor=getCursor(context),currentSource=context.source;context.options.isPreTag(tag)&&(context.inPre=!0);let props=parseAttributes(context,type);type===0&&!context.inVPre&&props.some(p2=>p2.type===7&&p2.name==="pre")&&(context.inVPre=!0,extend(context,cursor),context.source=currentSource,props=parseAttributes(context,type).filter(p2=>p2.name!=="v-pre"));let isSelfClosing=!1;if(context.source.length===0?emitError(context,9):(isSelfClosing=startsWith(context.source,"/>"),type===1&&isSelfClosing&&emitError(context,4),advanceBy(context,isSelfClosing?2:1)),type===1)return;let tagType=0;return context.inVPre||(tag==="slot"?tagType=2:tag==="template"?props.some(p2=>p2.type===7&&isSpecialTemplateDirective(p2.name))&&(tagType=3):isComponent(tag,props,context)&&(tagType=1)),{type:1,ns,tag,tagType,props,isSelfClosing,children:[],loc:getSelection(context,start),codegenNode:void 0}}function isComponent(tag,props,context){const options=context.options;if(options.isCustomElement(tag))return!1;if(tag==="component"||/^[A-Z]/.test(tag)||isCoreComponent(tag)||options.isBuiltInComponent&&options.isBuiltInComponent(tag)||options.isNativeTag&&!options.isNativeTag(tag))return!0;for(let i=0;i<props.length;i++){const p2=props[i];if(p2.type===6){if(p2.name==="is"&&p2.value){if(p2.value.content.startsWith("vue:"))return!0;if(checkCompatEnabled("COMPILER_IS_ON_ELEMENT",context,p2.loc))return!0}}else{if(p2.name==="is")return!0;if(p2.name==="bind"&&isStaticArgOf(p2.arg,"is")&&checkCompatEnabled("COMPILER_IS_ON_ELEMENT",context,p2.loc))return!0}}}function parseAttributes(context,type){const props=[],attributeNames=new Set;for(;context.source.length>0&&!startsWith(context.source,">")&&!startsWith(context.source,"/>");){if(startsWith(context.source,"/")){emitError(context,22),advanceBy(context,1),advanceSpaces(context);continue}type===1&&emitError(context,3);const attr=parseAttribute(context,attributeNames);attr.type===6&&attr.value&&attr.name==="class"&&(attr.value.content=attr.value.content.replace(/\s+/g," ").trim()),type===0&&props.push(attr),/^[^\t\r\n\f />]/.test(context.source)&&emitError(context,15),advanceSpaces(context)}return props}function parseAttribute(context,nameSet){var _a;const start=getCursor(context),name=/^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source)[0];nameSet.has(name)&&emitError(context,2),nameSet.add(name),name[0]==="="&&emitError(context,19);{const pattern=/["'<]/g;let m;for(;m=pattern.exec(name);)emitError(context,17,m.index)}advanceBy(context,name.length);let value;/^[\t\r\n\f ]*=/.test(context.source)&&(advanceSpaces(context),advanceBy(context,1),advanceSpaces(context),value=parseAttributeValue(context),value||emitError(context,13));const loc=getSelection(context,start);if(!context.inVPre&&/^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)){const match2=/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);let isPropShorthand=startsWith(name,"."),dirName=match2[1]||(isPropShorthand||startsWith(name,":")?"bind":startsWith(name,"@")?"on":"slot"),arg;if(match2[2]){const isSlot=dirName==="slot",startOffset=name.lastIndexOf(match2[2],name.length-(((_a=match2[3])==null?void 0:_a.length)||0)),loc2=getSelection(context,getNewPosition(context,start,startOffset),getNewPosition(context,start,startOffset+match2[2].length+(isSlot&&match2[3]||"").length));let content=match2[2],isStatic=!0;content.startsWith("[")?(isStatic=!1,content.endsWith("]")?content=content.slice(1,content.length-1):(emitError(context,27),content=content.slice(1))):isSlot&&(content+=match2[3]||""),arg={type:4,content,isStatic,constType:isStatic?3:0,loc:loc2}}if(value&&value.isQuoted){const valueLoc=value.loc;valueLoc.start.offset++,valueLoc.start.column++,valueLoc.end=advancePositionWithClone(valueLoc.start,value.content),valueLoc.source=valueLoc.source.slice(1,-1)}const modifiers=match2[3]?match2[3].slice(1).split("."):[];return isPropShorthand&&modifiers.push("prop"),dirName==="bind"&&arg&&modifiers.includes("sync")&&checkCompatEnabled("COMPILER_V_BIND_SYNC",context,loc,arg.loc.source)&&(dirName="model",modifiers.splice(modifiers.indexOf("sync"),1)),{type:7,name:dirName,exp:value&&{type:4,content:value.content,isStatic:!1,constType:0,loc:value.loc},arg,modifiers,loc}}return!context.inVPre&&startsWith(name,"v-")&&emitError(context,26),{type:6,name,value:value&&{type:2,content:value.content,loc:value.loc},loc}}function parseAttributeValue(context){const start=getCursor(context);let content;const quote=context.source[0],isQuoted=quote==='"'||quote==="'";if(isQuoted){advanceBy(context,1);const endIndex=context.source.indexOf(quote);endIndex===-1?content=parseTextData(context,context.source.length,4):(content=parseTextData(context,endIndex,4),advanceBy(context,1))}else{const match=/^[^\t\r\n\f >]+/.exec(context.source);if(!match)return;const unexpectedChars=/["'<=`]/g;let m;for(;m=unexpectedChars.exec(match[0]);)emitError(context,18,m.index);content=parseTextData(context,match[0].length,4)}return{content,isQuoted,loc:getSelection(context,start)}}function parseInterpolation(context,mode){const[open,close]=context.options.delimiters,closeIndex=context.source.indexOf(close,open.length);if(closeIndex===-1){emitError(context,25);return}const start=getCursor(context);advanceBy(context,open.length);const innerStart=getCursor(context),innerEnd=getCursor(context),rawContentLength=closeIndex-open.length,rawContent=context.source.slice(0,rawContentLength),preTrimContent=parseTextData(context,rawContentLength,mode),content=preTrimContent.trim(),startOffset=preTrimContent.indexOf(content);startOffset>0&&advancePositionWithMutation(innerStart,rawContent,startOffset);const endOffset=rawContentLength-(preTrimContent.length-content.length-startOffset);return advancePositionWithMutation(innerEnd,rawContent,endOffset),advanceBy(context,close.length),{type:5,content:{type:4,isStatic:!1,constType:0,content,loc:getSelection(context,innerStart,innerEnd)},loc:getSelection(context,start)}}function parseText(context,mode){const endTokens=mode===3?["]]>"]:["<",context.options.delimiters[0]];let endIndex=context.source.length;for(let i=0;i<endTokens.length;i++){const index=context.source.indexOf(endTokens[i],1);index!==-1&&endIndex>index&&(endIndex=index)}const start=getCursor(context);return{type:2,content:parseTextData(context,endIndex,mode),loc:getSelection(context,start)}}function parseTextData(context,length,mode){const rawText=context.source.slice(0,length);return advanceBy(context,length),mode===2||mode===3||!rawText.includes("&")?rawText:context.options.decodeEntities(rawText,mode===4)}function getCursor(context){const{column,line,offset}=context;return{column,line,offset}}function getSelection(context,start,end){return end=end||getCursor(context),{start,end,source:context.originalSource.slice(start.offset,end.offset)}}function last(xs){return xs[xs.length-1]}function startsWith(source,searchString){return source.startsWith(searchString)}function advanceBy(context,numberOfCharacters){const{source}=context;advancePositionWithMutation(context,source,numberOfCharacters),context.source=source.slice(numberOfCharacters)}function advanceSpaces(context){const match=/^[\t\r\n\f ]+/.exec(context.source);match&&advanceBy(context,match[0].length)}function getNewPosition(context,start,numberOfCharacters){return advancePositionWithClone(start,context.originalSource.slice(start.offset,numberOfCharacters),numberOfCharacters)}function emitError(context,code,offset,loc=getCursor(context)){offset&&(loc.offset+=offset,loc.column+=offset),context.options.onError(createCompilerError(code,{start:loc,end:loc,source:""}))}function isEnd(context,mode,ancestors){const s=context.source;switch(mode){case 0:if(startsWith(s,"</")){for(let i=ancestors.length-1;i>=0;--i)if(startsWithEndTagOpen(s,ancestors[i].tag))return!0}break;case 1:case 2:{const parent=last(ancestors);if(parent&&startsWithEndTagOpen(s,parent.tag))return!0;break}case 3:if(startsWith(s,"]]>"))return!0;break}return!s}function startsWithEndTagOpen(source,tag){return startsWith(source,"</")&&source.slice(2,2+tag.length).toLowerCase()===tag.toLowerCase()&&/[\t\r\n\f />]/.test(source[2+tag.length]||">")}function hoistStatic(root,context){walk(root,context,isSingleElementRoot(root,root.children[0]))}function isSingleElementRoot(root,child){const{children}=root;return children.length===1&&child.type===1&&!isSlotOutlet(child)}function walk(node,context,doNotHoistNode=!1){const{children}=node,originalCount=children.length;let hoistedCount=0;for(let i=0;i<children.length;i++){const child=children[i];if(child.type===1&&child.tagType===0){const constantType=doNotHoistNode?0:getConstantType(child,context);if(constantType>0){if(constantType>=2){child.codegenNode.patchFlag="-1",child.codegenNode=context.hoist(child.codegenNode),hoistedCount++;continue}}else{const codegenNode=child.codegenNode;if(codegenNode.type===13){const flag=getPatchFlag(codegenNode);if((!flag||flag===512||flag===1)&&getGeneratedPropsConstantType(child,context)>=2){const props=getNodeProps(child);props&&(codegenNode.props=context.hoist(props))}codegenNode.dynamicProps&&(codegenNode.dynamicProps=context.hoist(codegenNode.dynamicProps))}}}if(child.type===1){const isComponent2=child.tagType===1;isComponent2&&context.scopes.vSlot++,walk(child,context),isComponent2&&context.scopes.vSlot--}else if(child.type===11)walk(child,context,child.children.length===1);else if(child.type===9)for(let i2=0;i2<child.branches.length;i2++)walk(child.branches[i2],context,child.branches[i2].children.length===1)}if(hoistedCount&&context.transformHoist&&context.transformHoist(children,context,node),hoistedCount&&hoistedCount===originalCount&&node.type===1&&node.tagType===0&&node.codegenNode&&node.codegenNode.type===13&&isArray(node.codegenNode.children)){const hoisted=context.hoist(createArrayExpression(node.codegenNode.children));context.hmr&&(hoisted.content=`[...${hoisted.content}]`),node.codegenNode.children=hoisted}}function getConstantType(node,context){const{constantCache}=context;switch(node.type){case 1:if(node.tagType!==0)return 0;const cached=constantCache.get(node);if(cached!==void 0)return cached;const codegenNode=node.codegenNode;if(codegenNode.type!==13||codegenNode.isBlock&&node.tag!=="svg"&&node.tag!=="foreignObject")return 0;if(getPatchFlag(codegenNode))return constantCache.set(node,0),0;{let returnType2=3;const generatedPropsType=getGeneratedPropsConstantType(node,context);if(generatedPropsType===0)return constantCache.set(node,0),0;generatedPropsType<returnType2&&(returnType2=generatedPropsType);for(let i=0;i<node.children.length;i++){const childType=getConstantType(node.children[i],context);if(childType===0)return constantCache.set(node,0),0;childType<returnType2&&(returnType2=childType)}if(returnType2>1)for(let i=0;i<node.props.length;i++){const p2=node.props[i];if(p2.type===7&&p2.name==="bind"&&p2.exp){const expType=getConstantType(p2.exp,context);if(expType===0)return constantCache.set(node,0),0;expType<returnType2&&(returnType2=expType)}}if(codegenNode.isBlock){for(let i=0;i<node.props.length;i++)if(node.props[i].type===7)return constantCache.set(node,0),0;context.removeHelper(OPEN_BLOCK),context.removeHelper(getVNodeBlockHelper(context.inSSR,codegenNode.isComponent)),codegenNode.isBlock=!1,context.helper(getVNodeHelper(context.inSSR,codegenNode.isComponent))}return constantCache.set(node,returnType2),returnType2}case 2:case 3:return 3;case 9:case 11:case 10:return 0;case 5:case 12:return getConstantType(node.content,context);case 4:return node.constType;case 8:let returnType=3;for(let i=0;i<node.children.length;i++){const child=node.children[i];if(isString(child)||isSymbol(child))continue;const childType=getConstantType(child,context);if(childType===0)return 0;childType<returnType&&(returnType=childType)}return returnType;default:return 0}}const allowHoistedHelperSet=new Set([NORMALIZE_CLASS,NORMALIZE_STYLE,NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]);function getConstantTypeOfHelperCall(value,context){if(value.type===14&&!isString(value.callee)&&allowHoistedHelperSet.has(value.callee)){const arg=value.arguments[0];if(arg.type===4)return getConstantType(arg,context);if(arg.type===14)return getConstantTypeOfHelperCall(arg,context)}return 0}function getGeneratedPropsConstantType(node,context){let returnType=3;const props=getNodeProps(node);if(props&&props.type===15){const{properties}=props;for(let i=0;i<properties.length;i++){const{key,value}=properties[i],keyType=getConstantType(key,context);if(keyType===0)return keyType;keyType<returnType&&(returnType=keyType);let valueType;if(value.type===4?valueType=getConstantType(value,context):value.type===14?valueType=getConstantTypeOfHelperCall(value,context):valueType=0,valueType===0)return valueType;valueType<returnType&&(returnType=valueType)}}return returnType}function getNodeProps(node){const codegenNode=node.codegenNode;if(codegenNode.type===13)return codegenNode.props}function getPatchFlag(node){const flag=node.patchFlag;return flag?parseInt(flag,10):void 0}function createTransformContext(root,{filename="",prefixIdentifiers=!1,hoistStatic:hoistStatic2=!1,hmr=!1,cacheHandlers=!1,nodeTransforms=[],directiveTransforms={},transformHoist=null,isBuiltInComponent=NOOP,isCustomElement=NOOP,expressionPlugins=[],scopeId=null,slotted=!0,ssr=!1,inSSR=!1,ssrCssVars="",bindingMetadata=EMPTY_OBJ,inline=!1,isTS=!1,onError=defaultOnError,onWarn=defaultOnWarn,compatConfig}){const nameMatch=filename.replace(/\?.*$/,"").match(/([^/\\]+)\.\w+$/),context={selfName:nameMatch&&capitalize(camelize(nameMatch[1])),prefixIdentifiers,hoistStatic:hoistStatic2,hmr,cacheHandlers,nodeTransforms,directiveTransforms,transformHoist,isBuiltInComponent,isCustomElement,expressionPlugins,scopeId,slotted,ssr,inSSR,ssrCssVars,bindingMetadata,inline,isTS,onError,onWarn,compatConfig,root,helpers:new Map,components:new Set,directives:new Set,hoists:[],imports:[],constantCache:new WeakMap,temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:root,childIndex:0,inVOnce:!1,helper(name){const count=context.helpers.get(name)||0;return context.helpers.set(name,count+1),name},removeHelper(name){const count=context.helpers.get(name);if(count){const currentCount=count-1;currentCount?context.helpers.set(name,currentCount):context.helpers.delete(name)}},helperString(name){return`_${helperNameMap[context.helper(name)]}`},replaceNode(node){context.parent.children[context.childIndex]=context.currentNode=node},removeNode(node){const list=context.parent.children,removalIndex=node?list.indexOf(node):context.currentNode?context.childIndex:-1;!node||node===context.currentNode?(context.currentNode=null,context.onNodeRemoved()):context.childIndex>removalIndex&&(context.childIndex--,context.onNodeRemoved()),context.parent.children.splice(removalIndex,1)},onNodeRemoved:()=>{},addIdentifiers(exp){},removeIdentifiers(exp){},hoist(exp){isString(exp)&&(exp=createSimpleExpression(exp)),context.hoists.push(exp);const identifier=createSimpleExpression(`_hoisted_${context.hoists.length}`,!1,exp.loc,2);return identifier.hoisted=exp,identifier},cache(exp,isVNode2=!1){return createCacheExpression(context.cached++,exp,isVNode2)}};return context.filters=new Set,context}function transform(root,options){const context=createTransformContext(root,options);traverseNode(root,context),options.hoistStatic&&hoistStatic(root,context),options.ssr||createRootCodegen(root,context),root.helpers=new Set([...context.helpers.keys()]),root.components=[...context.components],root.directives=[...context.directives],root.imports=context.imports,root.hoists=context.hoists,root.temps=context.temps,root.cached=context.cached,root.filters=[...context.filters]}function createRootCodegen(root,context){const{helper}=context,{children}=root;if(children.length===1){const child=children[0];if(isSingleElementRoot(root,child)&&child.codegenNode){const codegenNode=child.codegenNode;codegenNode.type===13&&convertToBlock(codegenNode,context),root.codegenNode=codegenNode}else root.codegenNode=child}else if(children.length>1){let patchFlag=64;root.codegenNode=createVNodeCall(context,helper(FRAGMENT),void 0,root.children,patchFlag+"",void 0,void 0,!0,void 0,!1)}}function traverseChildren(parent,context){let i=0;const nodeRemoved=()=>{i--};for(;i<parent.children.length;i++){const child=parent.children[i];isString(child)||(context.parent=parent,context.childIndex=i,context.onNodeRemoved=nodeRemoved,traverseNode(child,context))}}function traverseNode(node,context){context.currentNode=node;const{nodeTransforms}=context,exitFns=[];for(let i2=0;i2<nodeTransforms.length;i2++){const onExit=nodeTransforms[i2](node,context);if(onExit&&(isArray(onExit)?exitFns.push(...onExit):exitFns.push(onExit)),context.currentNode)node=context.currentNode;else return}switch(node.type){case 3:context.ssr||context.helper(CREATE_COMMENT);break;case 5:context.ssr||context.helper(TO_DISPLAY_STRING);break;case 9:for(let i2=0;i2<node.branches.length;i2++)traverseNode(node.branches[i2],context);break;case 10:case 11:case 1:case 0:traverseChildren(node,context);break}context.currentNode=node;let i=exitFns.length;for(;i--;)exitFns[i]()}function createStructuralDirectiveTransform(name,fn){const matches2=isString(name)?n=>n===name:n=>name.test(n);return(node,context)=>{if(node.type===1){const{props}=node;if(node.tagType===3&&props.some(isVSlot))return;const exitFns=[];for(let i=0;i<props.length;i++){const prop=props[i];if(prop.type===7&&matches2(prop.name)){props.splice(i,1),i--;const onExit=fn(node,prop,context);onExit&&exitFns.push(onExit)}}return exitFns}}}const PURE_ANNOTATION="/*#__PURE__*/",aliasHelper=s=>`${helperNameMap[s]}: _${helperNameMap[s]}`;function createCodegenContext(ast,{mode="function",prefixIdentifiers=mode==="module",sourceMap=!1,filename="template.vue.html",scopeId=null,optimizeImports=!1,runtimeGlobalName="Vue",runtimeModuleName="vue",ssrRuntimeModuleName="vue/server-renderer",ssr=!1,isTS=!1,inSSR=!1}){const context={mode,prefixIdentifiers,sourceMap,filename,scopeId,optimizeImports,runtimeGlobalName,runtimeModuleName,ssrRuntimeModuleName,ssr,isTS,inSSR,source:ast.loc.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:!1,map:void 0,helper(key){return`_${helperNameMap[key]}`},push(code,node){context.code+=code},indent(){newline(++context.indentLevel)},deindent(withoutNewLine=!1){withoutNewLine?--context.indentLevel:newline(--context.indentLevel)},newline(){newline(context.indentLevel)}};function newline(n){context.push(`
`+"  ".repeat(n))}return context}function generate(ast,options={}){const context=createCodegenContext(ast,options);options.onContextCreated&&options.onContextCreated(context);const{mode,push,prefixIdentifiers,indent,deindent,newline,scopeId,ssr}=context,helpers=Array.from(ast.helpers),hasHelpers=helpers.length>0,useWithBlock=!prefixIdentifiers&&mode!=="module",isSetupInlined=!1,preambleContext=isSetupInlined?createCodegenContext(ast,options):context;genFunctionPreamble(ast,preambleContext);const functionName=ssr?"ssrRender":"render",signature=(ssr?["_ctx","_push","_parent","_attrs"]:["_ctx","_cache"]).join(", ");if(push(`function ${functionName}(${signature}) {`),indent(),useWithBlock&&(push("with (_ctx) {"),indent(),hasHelpers&&(push(`const { ${helpers.map(aliasHelper).join(", ")} } = _Vue`),push(`
`),newline())),ast.components.length&&(genAssets(ast.components,"component",context),(ast.directives.length||ast.temps>0)&&newline()),ast.directives.length&&(genAssets(ast.directives,"directive",context),ast.temps>0&&newline()),ast.filters&&ast.filters.length&&(newline(),genAssets(ast.filters,"filter",context),newline()),ast.temps>0){push("let ");for(let i=0;i<ast.temps;i++)push(`${i>0?", ":""}_temp${i}`)}return(ast.components.length||ast.directives.length||ast.temps)&&(push(`
`),newline()),ssr||push("return "),ast.codegenNode?genNode(ast.codegenNode,context):push("null"),useWithBlock&&(deindent(),push("}")),deindent(),push("}"),{ast,code:context.code,preamble:isSetupInlined?preambleContext.code:"",map:context.map?context.map.toJSON():void 0}}function genFunctionPreamble(ast,context){const{ssr,prefixIdentifiers,push,newline,runtimeModuleName,runtimeGlobalName,ssrRuntimeModuleName}=context,VueBinding=runtimeGlobalName,helpers=Array.from(ast.helpers);if(helpers.length>0&&(push(`const _Vue = ${VueBinding}
`),ast.hoists.length)){const staticHelpers=[CREATE_VNODE,CREATE_ELEMENT_VNODE,CREATE_COMMENT,CREATE_TEXT,CREATE_STATIC].filter(helper=>helpers.includes(helper)).map(aliasHelper).join(", ");push(`const { ${staticHelpers} } = _Vue
`)}genHoists(ast.hoists,context),newline(),push("return ")}function genAssets(assets,type,{helper,push,newline,isTS}){const resolver=helper(type==="filter"?RESOLVE_FILTER:type==="component"?RESOLVE_COMPONENT:RESOLVE_DIRECTIVE);for(let i=0;i<assets.length;i++){let id=assets[i];const maybeSelfReference=id.endsWith("__self");maybeSelfReference&&(id=id.slice(0,-6)),push(`const ${toValidAssetId(id,type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference?", true":""})${isTS?"!":""}`),i<assets.length-1&&newline()}}function genHoists(hoists,context){if(!hoists.length)return;context.pure=!0;const{push,newline,helper,scopeId,mode}=context;newline();for(let i=0;i<hoists.length;i++){const exp=hoists[i];exp&&(push(`const _hoisted_${i+1} = `),genNode(exp,context),newline())}context.pure=!1}function genNodeListAsArray(nodes,context){const multilines=nodes.length>3||!1;context.push("["),multilines&&context.indent(),genNodeList(nodes,context,multilines),multilines&&context.deindent(),context.push("]")}function genNodeList(nodes,context,multilines=!1,comma=!0){const{push,newline}=context;for(let i=0;i<nodes.length;i++){const node=nodes[i];isString(node)?push(node):isArray(node)?genNodeListAsArray(node,context):genNode(node,context),i<nodes.length-1&&(multilines?(comma&&push(","),newline()):comma&&push(", "))}}function genNode(node,context){if(isString(node)){context.push(node);return}if(isSymbol(node)){context.push(context.helper(node));return}switch(node.type){case 1:case 9:case 11:genNode(node.codegenNode,context);break;case 2:genText(node,context);break;case 4:genExpression(node,context);break;case 5:genInterpolation(node,context);break;case 12:genNode(node.codegenNode,context);break;case 8:genCompoundExpression(node,context);break;case 3:genComment(node,context);break;case 13:genVNodeCall(node,context);break;case 14:genCallExpression(node,context);break;case 15:genObjectExpression(node,context);break;case 17:genArrayExpression(node,context);break;case 18:genFunctionExpression(node,context);break;case 19:genConditionalExpression(node,context);break;case 20:genCacheExpression(node,context);break;case 21:genNodeList(node.body,context,!0,!1);break}}function genText(node,context){context.push(JSON.stringify(node.content),node)}function genExpression(node,context){const{content,isStatic}=node;context.push(isStatic?JSON.stringify(content):content,node)}function genInterpolation(node,context){const{push,helper,pure}=context;pure&&push(PURE_ANNOTATION),push(`${helper(TO_DISPLAY_STRING)}(`),genNode(node.content,context),push(")")}function genCompoundExpression(node,context){for(let i=0;i<node.children.length;i++){const child=node.children[i];isString(child)?context.push(child):genNode(child,context)}}function genExpressionAsPropertyKey(node,context){const{push}=context;if(node.type===8)push("["),genCompoundExpression(node,context),push("]");else if(node.isStatic){const text=isSimpleIdentifier(node.content)?node.content:JSON.stringify(node.content);push(text,node)}else push(`[${node.content}]`,node)}function genComment(node,context){const{push,helper,pure}=context;pure&&push(PURE_ANNOTATION),push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`,node)}function genVNodeCall(node,context){const{push,helper,pure}=context,{tag,props,children,patchFlag,dynamicProps,directives,isBlock,disableTracking,isComponent:isComponent2}=node;directives&&push(helper(WITH_DIRECTIVES)+"("),isBlock&&push(`(${helper(OPEN_BLOCK)}(${disableTracking?"true":""}), `),pure&&push(PURE_ANNOTATION);const callHelper=isBlock?getVNodeBlockHelper(context.inSSR,isComponent2):getVNodeHelper(context.inSSR,isComponent2);push(helper(callHelper)+"(",node),genNodeList(genNullableArgs([tag,props,children,patchFlag,dynamicProps]),context),push(")"),isBlock&&push(")"),directives&&(push(", "),genNode(directives,context),push(")"))}function genNullableArgs(args){let i=args.length;for(;i--&&args[i]==null;);return args.slice(0,i+1).map(arg=>arg||"null")}function genCallExpression(node,context){const{push,helper,pure}=context,callee=isString(node.callee)?node.callee:helper(node.callee);pure&&push(PURE_ANNOTATION),push(callee+"(",node),genNodeList(node.arguments,context),push(")")}function genObjectExpression(node,context){const{push,indent,deindent,newline}=context,{properties}=node;if(!properties.length){push("{}",node);return}const multilines=properties.length>1||!1;push(multilines?"{":"{ "),multilines&&indent();for(let i=0;i<properties.length;i++){const{key,value}=properties[i];genExpressionAsPropertyKey(key,context),push(": "),genNode(value,context),i<properties.length-1&&(push(","),newline())}multilines&&deindent(),push(multilines?"}":" }")}function genArrayExpression(node,context){genNodeListAsArray(node.elements,context)}function genFunctionExpression(node,context){const{push,indent,deindent}=context,{params,returns,body,newline,isSlot}=node;isSlot&&push(`_${helperNameMap[WITH_CTX]}(`),push("(",node),isArray(params)?genNodeList(params,context):params&&genNode(params,context),push(") => "),(newline||body)&&(push("{"),indent()),returns?(newline&&push("return "),isArray(returns)?genNodeListAsArray(returns,context):genNode(returns,context)):body&&genNode(body,context),(newline||body)&&(deindent(),push("}")),isSlot&&(node.isNonScopedSlot&&push(", undefined, true"),push(")"))}function genConditionalExpression(node,context){const{test,consequent,alternate,newline:needNewline}=node,{push,indent,deindent,newline}=context;if(test.type===4){const needsParens=!isSimpleIdentifier(test.content);needsParens&&push("("),genExpression(test,context),needsParens&&push(")")}else push("("),genNode(test,context),push(")");needNewline&&indent(),context.indentLevel++,needNewline||push(" "),push("? "),genNode(consequent,context),context.indentLevel--,needNewline&&newline(),needNewline||push(" "),push(": ");const isNested=alternate.type===19;isNested||context.indentLevel++,genNode(alternate,context),isNested||context.indentLevel--,needNewline&&deindent(!0)}function genCacheExpression(node,context){const{push,helper,indent,deindent,newline}=context;push(`_cache[${node.index}] || (`),node.isVNode&&(indent(),push(`${helper(SET_BLOCK_TRACKING)}(-1),`),newline()),push(`_cache[${node.index}] = `),genNode(node.value,context),node.isVNode&&(push(","),newline(),push(`${helper(SET_BLOCK_TRACKING)}(1),`),newline(),push(`_cache[${node.index}]`),deindent()),push(")")}new RegExp("\\b"+"arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b")+"\\b");const transformIf=createStructuralDirectiveTransform(/^(if|else|else-if)$/,(node,dir,context)=>processIf(node,dir,context,(ifNode,branch,isRoot)=>{const siblings=context.parent.children;let i=siblings.indexOf(ifNode),key=0;for(;i-->=0;){const sibling=siblings[i];sibling&&sibling.type===9&&(key+=sibling.branches.length)}return()=>{if(isRoot)ifNode.codegenNode=createCodegenNodeForBranch(branch,key,context);else{const parentCondition=getParentCondition(ifNode.codegenNode);parentCondition.alternate=createCodegenNodeForBranch(branch,key+ifNode.branches.length-1,context)}}}));function processIf(node,dir,context,processCodegen){if(dir.name!=="else"&&(!dir.exp||!dir.exp.content.trim())){const loc=dir.exp?dir.exp.loc:node.loc;context.onError(createCompilerError(28,dir.loc)),dir.exp=createSimpleExpression("true",!1,loc)}if(dir.name==="if"){const branch=createIfBranch(node,dir),ifNode={type:9,loc:node.loc,branches:[branch]};if(context.replaceNode(ifNode),processCodegen)return processCodegen(ifNode,branch,!0)}else{const siblings=context.parent.children;let i=siblings.indexOf(node);for(;i-->=-1;){const sibling=siblings[i];if(sibling&&sibling.type===3){context.removeNode(sibling);continue}if(sibling&&sibling.type===2&&!sibling.content.trim().length){context.removeNode(sibling);continue}if(sibling&&sibling.type===9){dir.name==="else-if"&&sibling.branches[sibling.branches.length-1].condition===void 0&&context.onError(createCompilerError(30,node.loc)),context.removeNode();const branch=createIfBranch(node,dir);sibling.branches.push(branch);const onExit=processCodegen&&processCodegen(sibling,branch,!1);traverseNode(branch,context),onExit&&onExit(),context.currentNode=null}else context.onError(createCompilerError(30,node.loc));break}}}function createIfBranch(node,dir){const isTemplateIf=node.tagType===3;return{type:10,loc:node.loc,condition:dir.name==="else"?void 0:dir.exp,children:isTemplateIf&&!findDir(node,"for")?node.children:[node],userKey:findProp(node,"key"),isTemplateIf}}function createCodegenNodeForBranch(branch,keyIndex,context){return branch.condition?createConditionalExpression(branch.condition,createChildrenCodegenNode(branch,keyIndex,context),createCallExpression(context.helper(CREATE_COMMENT),['""',"true"])):createChildrenCodegenNode(branch,keyIndex,context)}function createChildrenCodegenNode(branch,keyIndex,context){const{helper}=context,keyProperty=createObjectProperty("key",createSimpleExpression(`${keyIndex}`,!1,locStub,2)),{children}=branch,firstChild=children[0];if(children.length!==1||firstChild.type!==1)if(children.length===1&&firstChild.type===11){const vnodeCall=firstChild.codegenNode;return injectProp(vnodeCall,keyProperty,context),vnodeCall}else{let patchFlag=64;return createVNodeCall(context,helper(FRAGMENT),createObjectExpression([keyProperty]),children,patchFlag+"",void 0,void 0,!0,!1,!1,branch.loc)}else{const ret=firstChild.codegenNode,vnodeCall=getMemoedVNodeCall(ret);return vnodeCall.type===13&&convertToBlock(vnodeCall,context),injectProp(vnodeCall,keyProperty,context),ret}}function getParentCondition(node){for(;;)if(node.type===19)if(node.alternate.type===19)node=node.alternate;else return node;else node.type===20&&(node=node.value)}const transformFor=createStructuralDirectiveTransform("for",(node,dir,context)=>{const{helper,removeHelper}=context;return processFor(node,dir,context,forNode=>{const renderExp=createCallExpression(helper(RENDER_LIST),[forNode.source]),isTemplate=isTemplateNode(node),memo=findDir(node,"memo"),keyProp=findProp(node,"key"),keyExp=keyProp&&(keyProp.type===6?createSimpleExpression(keyProp.value.content,!0):keyProp.exp),keyProperty=keyProp?createObjectProperty("key",keyExp):null,isStableFragment=forNode.source.type===4&&forNode.source.constType>0,fragmentFlag=isStableFragment?64:keyProp?128:256;return forNode.codegenNode=createVNodeCall(context,helper(FRAGMENT),void 0,renderExp,fragmentFlag+"",void 0,void 0,!0,!isStableFragment,!1,node.loc),()=>{let childBlock;const{children}=forNode,needFragmentWrapper=children.length!==1||children[0].type!==1,slotOutlet=isSlotOutlet(node)?node:isTemplate&&node.children.length===1&&isSlotOutlet(node.children[0])?node.children[0]:null;if(slotOutlet?(childBlock=slotOutlet.codegenNode,isTemplate&&keyProperty&&injectProp(childBlock,keyProperty,context)):needFragmentWrapper?childBlock=createVNodeCall(context,helper(FRAGMENT),keyProperty?createObjectExpression([keyProperty]):void 0,node.children,"64",void 0,void 0,!0,void 0,!1):(childBlock=children[0].codegenNode,isTemplate&&keyProperty&&injectProp(childBlock,keyProperty,context),childBlock.isBlock!==!isStableFragment&&(childBlock.isBlock?(removeHelper(OPEN_BLOCK),removeHelper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent))):removeHelper(getVNodeHelper(context.inSSR,childBlock.isComponent))),childBlock.isBlock=!isStableFragment,childBlock.isBlock?(helper(OPEN_BLOCK),helper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent))):helper(getVNodeHelper(context.inSSR,childBlock.isComponent))),memo){const loop=createFunctionExpression(createForLoopParams(forNode.parseResult,[createSimpleExpression("_cached")]));loop.body=createBlockStatement([createCompoundExpression(["const _memo = (",memo.exp,")"]),createCompoundExpression(["if (_cached",...keyExp?[" && _cached.key === ",keyExp]:[],` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`]),createCompoundExpression(["const _item = ",childBlock]),createSimpleExpression("_item.memo = _memo"),createSimpleExpression("return _item")]),renderExp.arguments.push(loop,createSimpleExpression("_cache"),createSimpleExpression(String(context.cached++)))}else renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult),childBlock,!0))}})});function processFor(node,dir,context,processCodegen){if(!dir.exp){context.onError(createCompilerError(31,dir.loc));return}const parseResult=parseForExpression(dir.exp);if(!parseResult){context.onError(createCompilerError(32,dir.loc));return}const{addIdentifiers,removeIdentifiers,scopes}=context,{source,value,key,index}=parseResult,forNode={type:11,loc:dir.loc,source,valueAlias:value,keyAlias:key,objectIndexAlias:index,parseResult,children:isTemplateNode(node)?node.children:[node]};context.replaceNode(forNode),scopes.vFor++;const onExit=processCodegen&&processCodegen(forNode);return()=>{scopes.vFor--,onExit&&onExit()}}const forIteratorRE=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,stripParensRE=/^\(|\)$/g;function parseForExpression(input,context){const loc=input.loc,exp=input.content,inMatch=exp.match(forAliasRE);if(!inMatch)return;const[,LHS,RHS]=inMatch,result={source:createAliasExpression(loc,RHS.trim(),exp.indexOf(RHS,LHS.length)),value:void 0,key:void 0,index:void 0};let valueContent=LHS.trim().replace(stripParensRE,"").trim();const trimmedOffset=LHS.indexOf(valueContent),iteratorMatch=valueContent.match(forIteratorRE);if(iteratorMatch){valueContent=valueContent.replace(forIteratorRE,"").trim();const keyContent=iteratorMatch[1].trim();let keyOffset;if(keyContent&&(keyOffset=exp.indexOf(keyContent,trimmedOffset+valueContent.length),result.key=createAliasExpression(loc,keyContent,keyOffset)),iteratorMatch[2]){const indexContent=iteratorMatch[2].trim();indexContent&&(result.index=createAliasExpression(loc,indexContent,exp.indexOf(indexContent,result.key?keyOffset+keyContent.length:trimmedOffset+valueContent.length)))}}return valueContent&&(result.value=createAliasExpression(loc,valueContent,trimmedOffset)),result}function createAliasExpression(range,content,offset){return createSimpleExpression(content,!1,getInnerRange(range,offset,content.length))}function createForLoopParams({value,key,index},memoArgs=[]){return createParamsList([value,key,index,...memoArgs])}function createParamsList(args){let i=args.length;for(;i--&&!args[i];);return args.slice(0,i+1).map((arg,i2)=>arg||createSimpleExpression("_".repeat(i2+1),!1))}const defaultFallback=createSimpleExpression("undefined",!1),trackSlotScopes=(node,context)=>{if(node.type===1&&(node.tagType===1||node.tagType===3)){const vSlot=findDir(node,"slot");if(vSlot)return vSlot.exp,context.scopes.vSlot++,()=>{context.scopes.vSlot--}}},buildClientSlotFn=(props,_vForExp,children,loc)=>createFunctionExpression(props,children,!1,!0,children.length?children[0].loc:loc);function buildSlots(node,context,buildSlotFn=buildClientSlotFn){context.helper(WITH_CTX);const{children,loc}=node,slotsProperties=[],dynamicSlots=[];let hasDynamicSlots=context.scopes.vSlot>0||context.scopes.vFor>0;const onComponentSlot=findDir(node,"slot",!0);if(onComponentSlot){const{arg,exp}=onComponentSlot;arg&&!isStaticExp(arg)&&(hasDynamicSlots=!0),slotsProperties.push(createObjectProperty(arg||createSimpleExpression("default",!0),buildSlotFn(exp,void 0,children,loc)))}let hasTemplateSlots=!1,hasNamedDefaultSlot=!1;const implicitDefaultChildren=[],seenSlotNames=new Set;let conditionalBranchIndex=0;for(let i=0;i<children.length;i++){const slotElement=children[i];let slotDir;if(!isTemplateNode(slotElement)||!(slotDir=findDir(slotElement,"slot",!0))){slotElement.type!==3&&implicitDefaultChildren.push(slotElement);continue}if(onComponentSlot){context.onError(createCompilerError(37,slotDir.loc));break}hasTemplateSlots=!0;const{children:slotChildren,loc:slotLoc}=slotElement,{arg:slotName=createSimpleExpression("default",!0),exp:slotProps,loc:dirLoc}=slotDir;let staticSlotName;isStaticExp(slotName)?staticSlotName=slotName?slotName.content:"default":hasDynamicSlots=!0;const vFor=findDir(slotElement,"for"),slotFunction=buildSlotFn(slotProps,vFor==null?void 0:vFor.exp,slotChildren,slotLoc);let vIf,vElse;if(vIf=findDir(slotElement,"if"))hasDynamicSlots=!0,dynamicSlots.push(createConditionalExpression(vIf.exp,buildDynamicSlot(slotName,slotFunction,conditionalBranchIndex++),defaultFallback));else if(vElse=findDir(slotElement,/^else(-if)?$/,!0)){let j=i,prev;for(;j--&&(prev=children[j],prev.type===3););if(prev&&isTemplateNode(prev)&&findDir(prev,"if")){children.splice(i,1),i--;let conditional=dynamicSlots[dynamicSlots.length-1];for(;conditional.alternate.type===19;)conditional=conditional.alternate;conditional.alternate=vElse.exp?createConditionalExpression(vElse.exp,buildDynamicSlot(slotName,slotFunction,conditionalBranchIndex++),defaultFallback):buildDynamicSlot(slotName,slotFunction,conditionalBranchIndex++)}else context.onError(createCompilerError(30,vElse.loc))}else if(vFor){hasDynamicSlots=!0;const parseResult=vFor.parseResult||parseForExpression(vFor.exp);parseResult?dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST),[parseResult.source,createFunctionExpression(createForLoopParams(parseResult),buildDynamicSlot(slotName,slotFunction),!0)])):context.onError(createCompilerError(32,vFor.loc))}else{if(staticSlotName){if(seenSlotNames.has(staticSlotName)){context.onError(createCompilerError(38,dirLoc));continue}seenSlotNames.add(staticSlotName),staticSlotName==="default"&&(hasNamedDefaultSlot=!0)}slotsProperties.push(createObjectProperty(slotName,slotFunction))}}if(!onComponentSlot){const buildDefaultSlotProperty=(props,children2)=>{const fn=buildSlotFn(props,void 0,children2,loc);return context.compatConfig&&(fn.isNonScopedSlot=!0),createObjectProperty("default",fn)};hasTemplateSlots?implicitDefaultChildren.length&&implicitDefaultChildren.some(node2=>isNonWhitespaceContent(node2))&&(hasNamedDefaultSlot?context.onError(createCompilerError(39,implicitDefaultChildren[0].loc)):slotsProperties.push(buildDefaultSlotProperty(void 0,implicitDefaultChildren))):slotsProperties.push(buildDefaultSlotProperty(void 0,children))}const slotFlag=hasDynamicSlots?2:hasForwardedSlots(node.children)?3:1;let slots=createObjectExpression(slotsProperties.concat(createObjectProperty("_",createSimpleExpression(slotFlag+"",!1))),loc);return dynamicSlots.length&&(slots=createCallExpression(context.helper(CREATE_SLOTS),[slots,createArrayExpression(dynamicSlots)])),{slots,hasDynamicSlots}}function buildDynamicSlot(name,fn,index){const props=[createObjectProperty("name",name),createObjectProperty("fn",fn)];return index!=null&&props.push(createObjectProperty("key",createSimpleExpression(String(index),!0))),createObjectExpression(props)}function hasForwardedSlots(children){for(let i=0;i<children.length;i++){const child=children[i];switch(child.type){case 1:if(child.tagType===2||hasForwardedSlots(child.children))return!0;break;case 9:if(hasForwardedSlots(child.branches))return!0;break;case 10:case 11:if(hasForwardedSlots(child.children))return!0;break}}return!1}function isNonWhitespaceContent(node){return node.type!==2&&node.type!==12?!0:node.type===2?!!node.content.trim():isNonWhitespaceContent(node.content)}const directiveImportMap=new WeakMap,transformElement=(node,context)=>function(){if(node=context.currentNode,!(node.type===1&&(node.tagType===0||node.tagType===1)))return;const{tag,props}=node,isComponent2=node.tagType===1;let vnodeTag=isComponent2?resolveComponentType(node,context):`"${tag}"`;const isDynamicComponent=isObject(vnodeTag)&&vnodeTag.callee===RESOLVE_DYNAMIC_COMPONENT;let vnodeProps,vnodeChildren,vnodePatchFlag,patchFlag=0,vnodeDynamicProps,dynamicPropNames,vnodeDirectives,shouldUseBlock=isDynamicComponent||vnodeTag===TELEPORT||vnodeTag===SUSPENSE||!isComponent2&&(tag==="svg"||tag==="foreignObject");if(props.length>0){const propsBuildResult=buildProps(node,context,void 0,isComponent2,isDynamicComponent);vnodeProps=propsBuildResult.props,patchFlag=propsBuildResult.patchFlag,dynamicPropNames=propsBuildResult.dynamicPropNames;const directives=propsBuildResult.directives;vnodeDirectives=directives&&directives.length?createArrayExpression(directives.map(dir=>buildDirectiveArgs(dir,context))):void 0,propsBuildResult.shouldUseBlock&&(shouldUseBlock=!0)}if(node.children.length>0)if(vnodeTag===KEEP_ALIVE&&(shouldUseBlock=!0,patchFlag|=1024),isComponent2&&vnodeTag!==TELEPORT&&vnodeTag!==KEEP_ALIVE){const{slots,hasDynamicSlots}=buildSlots(node,context);vnodeChildren=slots,hasDynamicSlots&&(patchFlag|=1024)}else if(node.children.length===1&&vnodeTag!==TELEPORT){const child=node.children[0],type=child.type,hasDynamicTextChild=type===5||type===8;hasDynamicTextChild&&getConstantType(child,context)===0&&(patchFlag|=1),hasDynamicTextChild||type===2?vnodeChildren=child:vnodeChildren=node.children}else vnodeChildren=node.children;patchFlag!==0&&(vnodePatchFlag=String(patchFlag),dynamicPropNames&&dynamicPropNames.length&&(vnodeDynamicProps=stringifyDynamicPropNames(dynamicPropNames))),node.codegenNode=createVNodeCall(context,vnodeTag,vnodeProps,vnodeChildren,vnodePatchFlag,vnodeDynamicProps,vnodeDirectives,!!shouldUseBlock,!1,isComponent2,node.loc)};function resolveComponentType(node,context,ssr=!1){let{tag}=node;const isExplicitDynamic=isComponentTag(tag),isProp=findProp(node,"is");if(isProp)if(isExplicitDynamic||isCompatEnabled("COMPILER_IS_ON_ELEMENT",context)){const exp=isProp.type===6?isProp.value&&createSimpleExpression(isProp.value.content,!0):isProp.exp;if(exp)return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[exp])}else isProp.type===6&&isProp.value.content.startsWith("vue:")&&(tag=isProp.value.content.slice(4));const isDir=!isExplicitDynamic&&findDir(node,"is");if(isDir&&isDir.exp)return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[isDir.exp]);const builtIn=isCoreComponent(tag)||context.isBuiltInComponent(tag);return builtIn?(ssr||context.helper(builtIn),builtIn):(context.helper(RESOLVE_COMPONENT),context.components.add(tag),toValidAssetId(tag,"component"))}function buildProps(node,context,props=node.props,isComponent2,isDynamicComponent,ssr=!1){const{tag,loc:elementLoc,children}=node;let properties=[];const mergeArgs=[],runtimeDirectives=[],hasChildren=children.length>0;let shouldUseBlock=!1,patchFlag=0,hasRef=!1,hasClassBinding=!1,hasStyleBinding=!1,hasHydrationEventBinding=!1,hasDynamicKeys=!1,hasVnodeHook=!1;const dynamicPropNames=[],pushMergeArg=arg=>{properties.length&&(mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc)),properties=[]),arg&&mergeArgs.push(arg)},analyzePatchFlag=({key,value})=>{if(isStaticExp(key)){const name=key.content,isEventHandler=isOn(name);if(isEventHandler&&(!isComponent2||isDynamicComponent)&&name.toLowerCase()!=="onclick"&&name!=="onUpdate:modelValue"&&!isReservedProp(name)&&(hasHydrationEventBinding=!0),isEventHandler&&isReservedProp(name)&&(hasVnodeHook=!0),value.type===20||(value.type===4||value.type===8)&&getConstantType(value,context)>0)return;name==="ref"?hasRef=!0:name==="class"?hasClassBinding=!0:name==="style"?hasStyleBinding=!0:name!=="key"&&!dynamicPropNames.includes(name)&&dynamicPropNames.push(name),isComponent2&&(name==="class"||name==="style")&&!dynamicPropNames.includes(name)&&dynamicPropNames.push(name)}else hasDynamicKeys=!0};for(let i=0;i<props.length;i++){const prop=props[i];if(prop.type===6){const{loc,name,value}=prop;let isStatic=!0;if(name==="ref"&&(hasRef=!0,context.scopes.vFor>0&&properties.push(createObjectProperty(createSimpleExpression("ref_for",!0),createSimpleExpression("true")))),name==="is"&&(isComponentTag(tag)||value&&value.content.startsWith("vue:")||isCompatEnabled("COMPILER_IS_ON_ELEMENT",context)))continue;properties.push(createObjectProperty(createSimpleExpression(name,!0,getInnerRange(loc,0,name.length)),createSimpleExpression(value?value.content:"",isStatic,value?value.loc:loc)))}else{const{name,arg,exp,loc,modifiers}=prop,isVBind=name==="bind",isVOn=name==="on";if(name==="slot"){isComponent2||context.onError(createCompilerError(40,loc));continue}if(name==="once"||name==="memo"||name==="is"||isVBind&&isStaticArgOf(arg,"is")&&(isComponentTag(tag)||isCompatEnabled("COMPILER_IS_ON_ELEMENT",context))||isVOn&&ssr)continue;if((isVBind&&isStaticArgOf(arg,"key")||isVOn&&hasChildren&&isStaticArgOf(arg,"vue:before-update"))&&(shouldUseBlock=!0),isVBind&&isStaticArgOf(arg,"ref")&&context.scopes.vFor>0&&properties.push(createObjectProperty(createSimpleExpression("ref_for",!0),createSimpleExpression("true"))),!arg&&(isVBind||isVOn)){if(hasDynamicKeys=!0,exp)if(isVBind){if(pushMergeArg(),isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER",context)){mergeArgs.unshift(exp);continue}mergeArgs.push(exp)}else pushMergeArg({type:14,loc,callee:context.helper(TO_HANDLERS),arguments:isComponent2?[exp]:[exp,"true"]});else context.onError(createCompilerError(isVBind?34:35,loc));continue}isVBind&&modifiers.includes("prop")&&(patchFlag|=32);const directiveTransform=context.directiveTransforms[name];if(directiveTransform){const{props:props2,needRuntime}=directiveTransform(prop,node,context);!ssr&&props2.forEach(analyzePatchFlag),isVOn&&arg&&!isStaticExp(arg)?pushMergeArg(createObjectExpression(props2,elementLoc)):properties.push(...props2),needRuntime&&(runtimeDirectives.push(prop),isSymbol(needRuntime)&&directiveImportMap.set(prop,needRuntime))}else isBuiltInDirective(name)||(runtimeDirectives.push(prop),hasChildren&&(shouldUseBlock=!0))}}let propsExpression;if(mergeArgs.length?(pushMergeArg(),mergeArgs.length>1?propsExpression=createCallExpression(context.helper(MERGE_PROPS),mergeArgs,elementLoc):propsExpression=mergeArgs[0]):properties.length&&(propsExpression=createObjectExpression(dedupeProperties(properties),elementLoc)),hasDynamicKeys?patchFlag|=16:(hasClassBinding&&!isComponent2&&(patchFlag|=2),hasStyleBinding&&!isComponent2&&(patchFlag|=4),dynamicPropNames.length&&(patchFlag|=8),hasHydrationEventBinding&&(patchFlag|=32)),!shouldUseBlock&&(patchFlag===0||patchFlag===32)&&(hasRef||hasVnodeHook||runtimeDirectives.length>0)&&(patchFlag|=512),!context.inSSR&&propsExpression)switch(propsExpression.type){case 15:let classKeyIndex=-1,styleKeyIndex=-1,hasDynamicKey=!1;for(let i=0;i<propsExpression.properties.length;i++){const key=propsExpression.properties[i].key;isStaticExp(key)?key.content==="class"?classKeyIndex=i:key.content==="style"&&(styleKeyIndex=i):key.isHandlerKey||(hasDynamicKey=!0)}const classProp=propsExpression.properties[classKeyIndex],styleProp=propsExpression.properties[styleKeyIndex];hasDynamicKey?propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[propsExpression]):(classProp&&!isStaticExp(classProp.value)&&(classProp.value=createCallExpression(context.helper(NORMALIZE_CLASS),[classProp.value])),styleProp&&(hasStyleBinding||styleProp.value.type===4&&styleProp.value.content.trim()[0]==="["||styleProp.value.type===17)&&(styleProp.value=createCallExpression(context.helper(NORMALIZE_STYLE),[styleProp.value])));break;case 14:break;default:propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[createCallExpression(context.helper(GUARD_REACTIVE_PROPS),[propsExpression])]);break}return{props:propsExpression,directives:runtimeDirectives,patchFlag,dynamicPropNames,shouldUseBlock}}function dedupeProperties(properties){const knownProps=new Map,deduped=[];for(let i=0;i<properties.length;i++){const prop=properties[i];if(prop.key.type===8||!prop.key.isStatic){deduped.push(prop);continue}const name=prop.key.content,existing=knownProps.get(name);existing?(name==="style"||name==="class"||isOn(name))&&mergeAsArray(existing,prop):(knownProps.set(name,prop),deduped.push(prop))}return deduped}function mergeAsArray(existing,incoming){existing.value.type===17?existing.value.elements.push(incoming.value):existing.value=createArrayExpression([existing.value,incoming.value],existing.loc)}function buildDirectiveArgs(dir,context){const dirArgs=[],runtime=directiveImportMap.get(dir);runtime?dirArgs.push(context.helperString(runtime)):(context.helper(RESOLVE_DIRECTIVE),context.directives.add(dir.name),dirArgs.push(toValidAssetId(dir.name,"directive")));const{loc}=dir;if(dir.exp&&dirArgs.push(dir.exp),dir.arg&&(dir.exp||dirArgs.push("void 0"),dirArgs.push(dir.arg)),Object.keys(dir.modifiers).length){dir.arg||(dir.exp||dirArgs.push("void 0"),dirArgs.push("void 0"));const trueExpression=createSimpleExpression("true",!1,loc);dirArgs.push(createObjectExpression(dir.modifiers.map(modifier=>createObjectProperty(modifier,trueExpression)),loc))}return createArrayExpression(dirArgs,dir.loc)}function stringifyDynamicPropNames(props){let propsNamesString="[";for(let i=0,l=props.length;i<l;i++)propsNamesString+=JSON.stringify(props[i]),i<l-1&&(propsNamesString+=", ");return propsNamesString+"]"}function isComponentTag(tag){return tag==="component"||tag==="Component"}const transformSlotOutlet=(node,context)=>{if(isSlotOutlet(node)){const{children,loc}=node,{slotName,slotProps}=processSlotOutlet(node,context),slotArgs=[context.prefixIdentifiers?"_ctx.$slots":"$slots",slotName,"{}","undefined","true"];let expectedLen=2;slotProps&&(slotArgs[2]=slotProps,expectedLen=3),children.length&&(slotArgs[3]=createFunctionExpression([],children,!1,!1,loc),expectedLen=4),context.scopeId&&!context.slotted&&(expectedLen=5),slotArgs.splice(expectedLen),node.codegenNode=createCallExpression(context.helper(RENDER_SLOT),slotArgs,loc)}};function processSlotOutlet(node,context){let slotName='"default"',slotProps;const nonNameProps=[];for(let i=0;i<node.props.length;i++){const p2=node.props[i];p2.type===6?p2.value&&(p2.name==="name"?slotName=JSON.stringify(p2.value.content):(p2.name=camelize(p2.name),nonNameProps.push(p2))):p2.name==="bind"&&isStaticArgOf(p2.arg,"name")?p2.exp&&(slotName=p2.exp):(p2.name==="bind"&&p2.arg&&isStaticExp(p2.arg)&&(p2.arg.content=camelize(p2.arg.content)),nonNameProps.push(p2))}if(nonNameProps.length>0){const{props,directives}=buildProps(node,context,nonNameProps,!1,!1);slotProps=props,directives.length&&context.onError(createCompilerError(36,directives[0].loc))}return{slotName,slotProps}}const fnExpRE=/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,transformOn$1=(dir,node,context,augmentor)=>{const{loc,modifiers,arg}=dir;!dir.exp&&!modifiers.length&&context.onError(createCompilerError(35,loc));let eventName;if(arg.type===4)if(arg.isStatic){let rawName=arg.content;rawName.startsWith("vue:")&&(rawName=`vnode-${rawName.slice(4)}`);const eventString=node.tagType!==0||rawName.startsWith("vnode")||!/[A-Z]/.test(rawName)?toHandlerKey(camelize(rawName)):`on:${rawName}`;eventName=createSimpleExpression(eventString,!0,arg.loc)}else eventName=createCompoundExpression([`${context.helperString(TO_HANDLER_KEY)}(`,arg,")"]);else eventName=arg,eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`),eventName.children.push(")");let exp=dir.exp;exp&&!exp.content.trim()&&(exp=void 0);let shouldCache=context.cacheHandlers&&!exp&&!context.inVOnce;if(exp){const isMemberExp=isMemberExpression(exp.content),isInlineStatement=!(isMemberExp||fnExpRE.test(exp.content)),hasMultipleStatements=exp.content.includes(";");(isInlineStatement||shouldCache&&isMemberExp)&&(exp=createCompoundExpression([`${isInlineStatement?"$event":"(...args)"} => ${hasMultipleStatements?"{":"("}`,exp,hasMultipleStatements?"}":")"]))}let ret={props:[createObjectProperty(eventName,exp||createSimpleExpression("() => {}",!1,loc))]};return augmentor&&(ret=augmentor(ret)),shouldCache&&(ret.props[0].value=context.cache(ret.props[0].value)),ret.props.forEach(p2=>p2.key.isHandlerKey=!0),ret},transformBind=(dir,_node,context)=>{const{exp,modifiers,loc}=dir,arg=dir.arg;return arg.type!==4?(arg.children.unshift("("),arg.children.push(') || ""')):arg.isStatic||(arg.content=`${arg.content} || ""`),modifiers.includes("camel")&&(arg.type===4?arg.isStatic?arg.content=camelize(arg.content):arg.content=`${context.helperString(CAMELIZE)}(${arg.content})`:(arg.children.unshift(`${context.helperString(CAMELIZE)}(`),arg.children.push(")"))),context.inSSR||(modifiers.includes("prop")&&injectPrefix(arg,"."),modifiers.includes("attr")&&injectPrefix(arg,"^")),!exp||exp.type===4&&!exp.content.trim()?(context.onError(createCompilerError(34,loc)),{props:[createObjectProperty(arg,createSimpleExpression("",!0,loc))]}):{props:[createObjectProperty(arg,exp)]}},injectPrefix=(arg,prefix)=>{arg.type===4?arg.isStatic?arg.content=prefix+arg.content:arg.content=`\`${prefix}\${${arg.content}}\``:(arg.children.unshift(`'${prefix}' + (`),arg.children.push(")"))},transformText=(node,context)=>{if(node.type===0||node.type===1||node.type===11||node.type===10)return()=>{const children=node.children;let currentContainer,hasText=!1;for(let i=0;i<children.length;i++){const child=children[i];if(isText$1(child)){hasText=!0;for(let j=i+1;j<children.length;j++){const next=children[j];if(isText$1(next))currentContainer||(currentContainer=children[i]=createCompoundExpression([child],child.loc)),currentContainer.children.push(" + ",next),children.splice(j,1),j--;else{currentContainer=void 0;break}}}}if(!(!hasText||children.length===1&&(node.type===0||node.type===1&&node.tagType===0&&!node.props.find(p2=>p2.type===7&&!context.directiveTransforms[p2.name])&&node.tag!=="template")))for(let i=0;i<children.length;i++){const child=children[i];if(isText$1(child)||child.type===8){const callArgs=[];(child.type!==2||child.content!==" ")&&callArgs.push(child),!context.ssr&&getConstantType(child,context)===0&&callArgs.push("1"),children[i]={type:12,content:child,loc:child.loc,codegenNode:createCallExpression(context.helper(CREATE_TEXT),callArgs)}}}}},seen$1=new WeakSet,transformOnce=(node,context)=>{if(node.type===1&&findDir(node,"once",!0))return seen$1.has(node)||context.inVOnce||context.inSSR?void 0:(seen$1.add(node),context.inVOnce=!0,context.helper(SET_BLOCK_TRACKING),()=>{context.inVOnce=!1;const cur=context.currentNode;cur.codegenNode&&(cur.codegenNode=context.cache(cur.codegenNode,!0))})},transformModel$1=(dir,node,context)=>{const{exp,arg}=dir;if(!exp)return context.onError(createCompilerError(41,dir.loc)),createTransformProps();const rawExp=exp.loc.source,expString=exp.type===4?exp.content:rawExp,bindingType=context.bindingMetadata[rawExp];if(bindingType==="props"||bindingType==="props-aliased")return context.onError(createCompilerError(44,exp.loc)),createTransformProps();const maybeRef=!1;if(!expString.trim()||!isMemberExpression(expString)&&!maybeRef)return context.onError(createCompilerError(42,exp.loc)),createTransformProps();const propName=arg||createSimpleExpression("modelValue",!0),eventName=arg?isStaticExp(arg)?`onUpdate:${camelize(arg.content)}`:createCompoundExpression(['"onUpdate:" + ',arg]):"onUpdate:modelValue";let assignmentExp;const eventArg=context.isTS?"($event: any)":"$event";assignmentExp=createCompoundExpression([`${eventArg} => ((`,exp,") = $event)"]);const props=[createObjectProperty(propName,dir.exp),createObjectProperty(eventName,assignmentExp)];if(dir.modifiers.length&&node.tagType===1){const modifiers=dir.modifiers.map(m=>(isSimpleIdentifier(m)?m:JSON.stringify(m))+": true").join(", "),modifiersKey=arg?isStaticExp(arg)?`${arg.content}Modifiers`:createCompoundExpression([arg,' + "Modifiers"']):"modelModifiers";props.push(createObjectProperty(modifiersKey,createSimpleExpression(`{ ${modifiers} }`,!1,dir.loc,2)))}return createTransformProps(props)};function createTransformProps(props=[]){return{props}}const validDivisionCharRE=/[\w).+\-_$\]]/,transformFilter=(node,context)=>{isCompatEnabled("COMPILER_FILTER",context)&&(node.type===5&&rewriteFilter(node.content,context),node.type===1&&node.props.forEach(prop=>{prop.type===7&&prop.name!=="for"&&prop.exp&&rewriteFilter(prop.exp,context)}))};function rewriteFilter(node,context){if(node.type===4)parseFilter(node,context);else for(let i=0;i<node.children.length;i++){const child=node.children[i];typeof child=="object"&&(child.type===4?parseFilter(child,context):child.type===8?rewriteFilter(node,context):child.type===5&&rewriteFilter(child.content,context))}}function parseFilter(node,context){const exp=node.content;let inSingle=!1,inDouble=!1,inTemplateString=!1,inRegex=!1,curly=0,square=0,paren=0,lastFilterIndex=0,c,prev,i,expression,filters=[];for(i=0;i<exp.length;i++)if(prev=c,c=exp.charCodeAt(i),inSingle)c===39&&prev!==92&&(inSingle=!1);else if(inDouble)c===34&&prev!==92&&(inDouble=!1);else if(inTemplateString)c===96&&prev!==92&&(inTemplateString=!1);else if(inRegex)c===47&&prev!==92&&(inRegex=!1);else if(c===124&&exp.charCodeAt(i+1)!==124&&exp.charCodeAt(i-1)!==124&&!curly&&!square&&!paren)expression===void 0?(lastFilterIndex=i+1,expression=exp.slice(0,i).trim()):pushFilter();else{switch(c){case 34:inDouble=!0;break;case 39:inSingle=!0;break;case 96:inTemplateString=!0;break;case 40:paren++;break;case 41:paren--;break;case 91:square++;break;case 93:square--;break;case 123:curly++;break;case 125:curly--;break}if(c===47){let j=i-1,p2;for(;j>=0&&(p2=exp.charAt(j),p2===" ");j--);(!p2||!validDivisionCharRE.test(p2))&&(inRegex=!0)}}expression===void 0?expression=exp.slice(0,i).trim():lastFilterIndex!==0&&pushFilter();function pushFilter(){filters.push(exp.slice(lastFilterIndex,i).trim()),lastFilterIndex=i+1}if(filters.length){for(i=0;i<filters.length;i++)expression=wrapFilter(expression,filters[i],context);node.content=expression}}function wrapFilter(exp,filter,context){context.helper(RESOLVE_FILTER);const i=filter.indexOf("(");if(i<0)return context.filters.add(filter),`${toValidAssetId(filter,"filter")}(${exp})`;{const name=filter.slice(0,i),args=filter.slice(i+1);return context.filters.add(name),`${toValidAssetId(name,"filter")}(${exp}${args!==")"?","+args:args}`}}const seen=new WeakSet,transformMemo=(node,context)=>{if(node.type===1){const dir=findDir(node,"memo");return!dir||seen.has(node)?void 0:(seen.add(node),()=>{const codegenNode=node.codegenNode||context.currentNode.codegenNode;codegenNode&&codegenNode.type===13&&(node.tagType!==1&&convertToBlock(codegenNode,context),node.codegenNode=createCallExpression(context.helper(WITH_MEMO),[dir.exp,createFunctionExpression(void 0,codegenNode),"_cache",String(context.cached++)]))})}};function getBaseTransformPreset(prefixIdentifiers){return[[transformOnce,transformIf,transformMemo,transformFor,transformFilter,transformSlotOutlet,transformElement,trackSlotScopes,transformText],{on:transformOn$1,bind:transformBind,model:transformModel$1}]}function baseCompile(template,options={}){const onError=options.onError||defaultOnError,isModuleMode=options.mode==="module";options.prefixIdentifiers===!0?onError(createCompilerError(47)):isModuleMode&&onError(createCompilerError(48));const prefixIdentifiers=!1;options.cacheHandlers&&onError(createCompilerError(49)),options.scopeId&&!isModuleMode&&onError(createCompilerError(50));const ast=isString(template)?baseParse(template,options):template,[nodeTransforms,directiveTransforms]=getBaseTransformPreset();return transform(ast,extend({},options,{prefixIdentifiers,nodeTransforms:[...nodeTransforms,...options.nodeTransforms||[]],directiveTransforms:extend({},directiveTransforms,options.directiveTransforms||{})})),generate(ast,extend({},options,{prefixIdentifiers}))}const noopDirectiveTransform=()=>({props:[]}),V_MODEL_RADIO=Symbol(""),V_MODEL_CHECKBOX=Symbol(""),V_MODEL_TEXT=Symbol(""),V_MODEL_SELECT=Symbol(""),V_MODEL_DYNAMIC=Symbol(""),V_ON_WITH_MODIFIERS=Symbol(""),V_ON_WITH_KEYS=Symbol(""),V_SHOW=Symbol(""),TRANSITION=Symbol(""),TRANSITION_GROUP=Symbol("");registerRuntimeHelpers({[V_MODEL_RADIO]:"vModelRadio",[V_MODEL_CHECKBOX]:"vModelCheckbox",[V_MODEL_TEXT]:"vModelText",[V_MODEL_SELECT]:"vModelSelect",[V_MODEL_DYNAMIC]:"vModelDynamic",[V_ON_WITH_MODIFIERS]:"withModifiers",[V_ON_WITH_KEYS]:"withKeys",[V_SHOW]:"vShow",[TRANSITION]:"Transition",[TRANSITION_GROUP]:"TransitionGroup"});let decoder;function decodeHtmlBrowser(raw,asAttr=!1){return decoder||(decoder=document.createElement("div")),asAttr?(decoder.innerHTML=`<div foo="${raw.replace(/"/g,"&quot;")}">`,decoder.children[0].getAttribute("foo")):(decoder.innerHTML=raw,decoder.textContent)}const isRawTextContainer=makeMap("style,iframe,script,noscript",!0),parserOptions={isVoidTag,isNativeTag:tag=>isHTMLTag(tag)||isSVGTag(tag),isPreTag:tag=>tag==="pre",decodeEntities:decodeHtmlBrowser,isBuiltInComponent:tag=>{if(isBuiltInType(tag,"Transition"))return TRANSITION;if(isBuiltInType(tag,"TransitionGroup"))return TRANSITION_GROUP},getNamespace(tag,parent){let ns=parent?parent.ns:0;if(parent&&ns===2)if(parent.tag==="annotation-xml"){if(tag==="svg")return 1;parent.props.some(a=>a.type===6&&a.name==="encoding"&&a.value!=null&&(a.value.content==="text/html"||a.value.content==="application/xhtml+xml"))&&(ns=0)}else/^m(?:[ions]|text)$/.test(parent.tag)&&tag!=="mglyph"&&tag!=="malignmark"&&(ns=0);else parent&&ns===1&&(parent.tag==="foreignObject"||parent.tag==="desc"||parent.tag==="title")&&(ns=0);if(ns===0){if(tag==="svg")return 1;if(tag==="math")return 2}return ns},getTextMode({tag,ns}){if(ns===0){if(tag==="textarea"||tag==="title")return 1;if(isRawTextContainer(tag))return 2}return 0}},transformStyle=node=>{node.type===1&&node.props.forEach((p2,i)=>{p2.type===6&&p2.name==="style"&&p2.value&&(node.props[i]={type:7,name:"bind",arg:createSimpleExpression("style",!0,p2.loc),exp:parseInlineCSS(p2.value.content,p2.loc),modifiers:[],loc:p2.loc})})},parseInlineCSS=(cssText,loc)=>{const normalized=parseStringStyle(cssText);return createSimpleExpression(JSON.stringify(normalized),!1,loc,3)};function createDOMCompilerError(code,loc){return createCompilerError(code,loc)}const transformVHtml=(dir,node,context)=>{const{exp,loc}=dir;return exp||context.onError(createDOMCompilerError(53,loc)),node.children.length&&(context.onError(createDOMCompilerError(54,loc)),node.children.length=0),{props:[createObjectProperty(createSimpleExpression("innerHTML",!0,loc),exp||createSimpleExpression("",!0))]}},transformVText=(dir,node,context)=>{const{exp,loc}=dir;return exp||context.onError(createDOMCompilerError(55,loc)),node.children.length&&(context.onError(createDOMCompilerError(56,loc)),node.children.length=0),{props:[createObjectProperty(createSimpleExpression("textContent",!0),exp?getConstantType(exp,context)>0?exp:createCallExpression(context.helperString(TO_DISPLAY_STRING),[exp],loc):createSimpleExpression("",!0))]}},transformModel=(dir,node,context)=>{const baseResult=transformModel$1(dir,node,context);if(!baseResult.props.length||node.tagType===1)return baseResult;dir.arg&&context.onError(createDOMCompilerError(58,dir.arg.loc));const{tag}=node,isCustomElement=context.isCustomElement(tag);if(tag==="input"||tag==="textarea"||tag==="select"||isCustomElement){let directiveToUse=V_MODEL_TEXT,isInvalidType=!1;if(tag==="input"||isCustomElement){const type=findProp(node,"type");if(type){if(type.type===7)directiveToUse=V_MODEL_DYNAMIC;else if(type.value)switch(type.value.content){case"radio":directiveToUse=V_MODEL_RADIO;break;case"checkbox":directiveToUse=V_MODEL_CHECKBOX;break;case"file":isInvalidType=!0,context.onError(createDOMCompilerError(59,dir.loc));break}}else hasDynamicKeyVBind(node)&&(directiveToUse=V_MODEL_DYNAMIC)}else tag==="select"&&(directiveToUse=V_MODEL_SELECT);isInvalidType||(baseResult.needRuntime=context.helper(directiveToUse))}else context.onError(createDOMCompilerError(57,dir.loc));return baseResult.props=baseResult.props.filter(p2=>!(p2.key.type===4&&p2.key.content==="modelValue")),baseResult},isEventOptionModifier=makeMap("passive,once,capture"),isNonKeyModifier=makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),maybeKeyModifier=makeMap("left,right"),isKeyboardEvent=makeMap("onkeyup,onkeydown,onkeypress",!0),resolveModifiers=(key,modifiers,context,loc)=>{const keyModifiers=[],nonKeyModifiers=[],eventOptionModifiers=[];for(let i=0;i<modifiers.length;i++){const modifier=modifiers[i];modifier==="native"&&checkCompatEnabled("COMPILER_V_ON_NATIVE",context)||isEventOptionModifier(modifier)?eventOptionModifiers.push(modifier):maybeKeyModifier(modifier)?isStaticExp(key)?isKeyboardEvent(key.content)?keyModifiers.push(modifier):nonKeyModifiers.push(modifier):(keyModifiers.push(modifier),nonKeyModifiers.push(modifier)):isNonKeyModifier(modifier)?nonKeyModifiers.push(modifier):keyModifiers.push(modifier)}return{keyModifiers,nonKeyModifiers,eventOptionModifiers}},transformClick=(key,event)=>isStaticExp(key)&&key.content.toLowerCase()==="onclick"?createSimpleExpression(event,!0):key.type!==4?createCompoundExpression(["(",key,`) === "onClick" ? "${event}" : (`,key,")"]):key,transformOn=(dir,node,context)=>transformOn$1(dir,node,context,baseResult=>{const{modifiers}=dir;if(!modifiers.length)return baseResult;let{key,value:handlerExp}=baseResult.props[0];const{keyModifiers,nonKeyModifiers,eventOptionModifiers}=resolveModifiers(key,modifiers,context,dir.loc);if(nonKeyModifiers.includes("right")&&(key=transformClick(key,"onContextmenu")),nonKeyModifiers.includes("middle")&&(key=transformClick(key,"onMouseup")),nonKeyModifiers.length&&(handlerExp=createCallExpression(context.helper(V_ON_WITH_MODIFIERS),[handlerExp,JSON.stringify(nonKeyModifiers)])),keyModifiers.length&&(!isStaticExp(key)||isKeyboardEvent(key.content))&&(handlerExp=createCallExpression(context.helper(V_ON_WITH_KEYS),[handlerExp,JSON.stringify(keyModifiers)])),eventOptionModifiers.length){const modifierPostfix=eventOptionModifiers.map(capitalize).join("");key=isStaticExp(key)?createSimpleExpression(`${key.content}${modifierPostfix}`,!0):createCompoundExpression(["(",key,`) + "${modifierPostfix}"`])}return{props:[createObjectProperty(key,handlerExp)]}}),transformShow=(dir,node,context)=>{const{exp,loc}=dir;return exp||context.onError(createDOMCompilerError(61,loc)),{props:[],needRuntime:context.helper(V_SHOW)}},ignoreSideEffectTags=(node,context)=>{node.type===1&&node.tagType===0&&(node.tag==="script"||node.tag==="style")&&context.removeNode()},DOMNodeTransforms=[transformStyle],DOMDirectiveTransforms={cloak:noopDirectiveTransform,html:transformVHtml,text:transformVText,model:transformModel,on:transformOn,show:transformShow};function compile(template,options={}){return baseCompile(template,extend({},parserOptions,options,{nodeTransforms:[ignoreSideEffectTags,...DOMNodeTransforms,...options.nodeTransforms||[]],directiveTransforms:extend({},DOMDirectiveTransforms,options.directiveTransforms||{}),transformHoist:null}))}const compileCache=Object.create(null);function compileToFunction(template,options){if(!isString(template))if(template.nodeType)template=template.innerHTML;else return NOOP;const key=template,cached=compileCache[key];if(cached)return cached;if(template[0]==="#"){const el=document.querySelector(template);template=el?el.innerHTML:""}const opts=extend({hoistStatic:!0,onError:void 0,onWarn:NOOP},options);!opts.isCustomElement&&typeof customElements<"u"&&(opts.isCustomElement=tag=>!!customElements.get(tag));const{code}=compile(template,opts),render2=new Function("Vue",code)(runtimeDom);return render2._rc=!0,compileCache[key]=render2}registerRuntimeCompiler(compileToFunction);export{toRef as A,onBeforeUnmount as B,renderList as C,withDirectives as D,vModelDynamic as E,Fragment as F,normalizeStyle as G,withModifiers as H,vModelText as I,createApp as a,isReactive as b,computed as c,reactive as d,defineComponent as e,openBlock as f,createElementBlock as g,h,isVNode as i,renderSlot as j,createTextVNode as k,createCommentVNode as l,createBaseVNode as m,normalizeClass as n,onMounted as o,createBlock as p,mergeProps as q,ref as r,normalizeProps as s,toDisplayString as t,unref as u,guardReactiveProps as v,withCtx as w,createVNode as x,watch as y,resolveDynamicComponent as z};
